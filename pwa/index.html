<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Hygiene & Cleaning Products Store</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Roboto:wght@700&display=swap" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=star" />
    <link rel="manifest" href="manifest.json" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://static-na.payments-amazon.com/OffAmazonPayments/us/js/Widgets.js"></script>

    <style>
      /* Apply Inter font to the body as the default font family */
      body {
        font-family: 'Inter', sans-serif;
      }
      /* Apply Roboto font to heading elements (h1 to h6) */
      h1, h2, h3, h4, h5, h6 {
        font-family: 'Roboto', sans-serif;
      }

      /* --- Custom CSS for Chatbot Widget --- */
      /* Base styles and transitions for the main chatbot container */
      #chatbot {
          transition: height 0.3s ease, opacity 0.3s ease, transform 0.3s ease; /* Smooth transitions for changes */
          display: flex; /* Use flexbox to arrange children (header, messages, form) vertically */
          flex-direction: column; /* Stack children vertically */
          height: 4rem; /* Default collapsed height (should match header height) */
          opacity: 1; /* Default visible state */
          transform: translateY(0); /* Default position (no transformation) */
          /* By default, the chatbot is hidden using `style="display: none;"` in the HTML.
             When shown by JS, display becomes 'flex'. */
      }

      /* Styles for the chatbot when it is NOT in the 'expanded' state (collapsed) */
      #chatbot:not(.expanded) {
          /* When collapsed, explicitly hide the messages area and the input form */
          #chatbot-messages, #chatbot-form {
              display: none;
          }
          /* Optional: Add border-radius only to the top when collapsed */
           border-bottom-left-radius: 0;
           border-bottom-right-radius: 0;
      }

      /* Styles for the chatbot when it IS in the 'expanded' state */
       #chatbot.expanded {
           height: 24rem; /* Example expanded height (adjust as needed) */
           max-height: 80vh; /* Prevent it from getting too tall on smaller screens */
            /* When expanded, ensure messages area and form are displayed */
           #chatbot-messages, #chatbot-form {
               display: flex; /* Use flex for messages/form layout */
           }
            /* Ensure the messages area grows to fill available space */
           #chatbot-messages {
               flex-grow: 1;
               /* Additional flex properties might be needed depending on layout inside */
           }
            /* Ensure the form stays at the bottom */
           #chatbot-form {
               flex-shrink: 0; /* Prevent form from shrinking */
           }
            /* Reset border-radius when expanded */
           border-radius: 0.75rem; /* Or the value defined by Tailwind class rounded-xl */
       }

       /* Ensure the chatbot messages area scrolls if content overflows vertically */
       #chatbot-messages {
           overflow-x: hidden; /* Hide horizontal scrollbar */
           overflow-y: auto; /* Enable vertical scrollbar */
           white-space: normal; /* Allow wrapping */
           padding: 1rem; /* Example padding, adjust as needed */
           display: flex; /* Use flexbox for vertical layout */
           flex-direction: column; /* Arrange chat bubbles vertically */
           gap: 0.5rem; /* Add spacing between chat bubbles */
       }
       /* Reset default padding from Tailwind if needed, e.g., .p-4 */
       #chatbot-messages.p-4 { padding: 1rem; }


       /* --- Custom CSS for Utility Classes --- */
       /* CSS for the clearfix utility class, used to clear floats */
       .clearfix::after {
          content: ""; /* Required for clearfix */
          display: table; /* Required for clearfix */
          clear: both; /* Clears both left and right floats */
       }

        /* --- CSS for Animations --- */
        /* Keyframes for the fadeIn animation, used for chat messages */
        @keyframes fadeIn {
          from { opacity: 0; transform: translateY(10px); } /* Start invisible and slightly down */
          to { opacity: 1; transform: translateY(0); } /* End fully visible in original position */
        }
        /* Apply the fadeIn animation to elements with this class */
        .animate-fadeIn {
          animation: fadeIn 0.3s ease forwards; /* Apply animation over 0.3s with ease timing, keep final state */
        }
    </style>
  </head>
  <body class="bg-gray-50 min-h-screen flex flex-col">
    <header class="bg-white shadow p-4 text-center flex flex-col max-w-screen-xl mx-auto space-y-4">
      <div class="flex flex-col items-center space-y-2">
        <h1 class="text-2xl font-semibold text-gray-800">Hygiene & Cleaning Products</h1>
        <div class="flex space-x-4">
          <a href="#" aria-label="Share on Facebook" id="share-facebook" class="text-blue-600 hover:text-blue-800" target="_blank" rel="noopener noreferrer"><span class="material-icons">facebook</span></a>
          <a href="#" aria-label="Share on Twitter" id="share-twitter" class="text-blue-400 hover:text-blue-600" target="_blank" rel="noopener noreferrer"><span class="material-icons">twitter</span></a>
          <a href="#" aria-label="Share on WhatsApp" id="share-whatsapp" class="text-green-500 hover:text-green-700" target="_blank" rel="noopener noreferrer"><span class="material-icons">whatsapp</span></a>
          <a href="#" aria-label="Share on LinkedIn" id="share-linkedin" class="text-blue-700 hover:text-blue-900" target="_blank" rel="noopener noreferrer"><span class="material-icons">linkedin</span></a>
        </div>
      </div>
      <div id="top-ad" class="w-full bg-yellow-100 border border-yellow-300 rounded p-4 text-center text-yellow-800 font-semibold">
        Your Ad Here - Promote Your Products!
      </div>
    </header>

    <main class="flex-grow container mx-auto p-4 max-w-screen-xl flex flex-col items-center pb-32">
      <div id="product-slider" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6 scrollbar-hide snap-x snap-mandatory scroll-smooth justify-center">
        </div>
      <div id="mid-ad" class="w-full bg-yellow-100 border border-yellow-300 rounded p-4 mt-6 text-center text-yellow-800 font-semibold max-w-screen-xl animate-bounce">
        Your Ad Here - Special Offers!
      </div>
      </main>

    <div id="popup-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50" role="dialog" aria-modal="true" aria-labelledby="popup-title" aria-describedby="popup-desc">
      <div class="bg-white rounded-lg max-w-3xl w-full p-6 relative shadow-lg overflow-y-auto max-h-[80vh]">
        <button id="popup-close" aria-label="Close popup" class="absolute top-2 right-2 text-gray-600 hover:text-gray-900 text-2xl font-bold focus:outline-none focus:ring-2 focus:ring-indigo-500">×</button>
        <div id="popup-content" class="overflow-auto">
          <h2 id="popup-title" class="sr-only">Popup Title</h2> <div id="popup-desc" class="sr-only">Popup content description</div> </div>
      </div>
    </div>

    <div id="chatbot" class="fixed bottom-4 right-4 w-80 max-w-full bg-white rounded-xl shadow-2xl border border-gray-300 overflow-hidden z-50" style="display: none;">
      <div class="bg-indigo-600 text-white p-4 flex justify-between items-center cursor-pointer select-none" id="chatbot-header" role="button" aria-expanded="false" aria-controls="chatbot-messages" tabindex="0">
        <h2 class="text-lg font-semibold">Help Chat</h2>
        <button id="chatbot-close" aria-label="Close chatbot" class="text-white text-2xl font-bold focus:outline-none focus:ring-2 focus:ring-white rounded">×</button>
      </div>
      <div id="chatbot-messages" class="flex-grow p-4 overflow-y-auto text-sm text-gray-900 bg-gray-50 space-y-2" role="log" aria-live="polite" aria-relevant="additions">
           </div>
      <form id="chatbot-form" class="p-4 border-t border-gray-300 flex space-x-2">
        <input type="text" id="chatbot-input" class="flex-grow border border-gray-300 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Ask me about products..." aria-label="Chat input" autocomplete="off" />
        <button type="submit" class="bg-indigo-600 text-white px-4 py-2 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 transition flex items-center justify-center">
          <span class="material-icons">send</span> </button>
      </form>
    </div>

    <div id="subscription-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center hidden z-50">
      <div class="bg-white rounded-xl max-w-md w-full p-6 relative shadow-lg">
        <button id="subscription-close" aria-label="Close subscription modal" class="absolute top-3 right-3 text-gray-600 hover:text-gray-900 text-2xl font-bold focus:outline-none focus:ring-2 focus:ring-indigo-500">×</button>
        <h2 class="text-xl font-bold mb-4 text-center text-indigo-700">Subscribe to Get Early Deals</h2>
        <form id="subscription-form" class="space-y-4">
          <div>
            <label for="subscription-email" class="block text-gray-700 font-semibold mb-1">Email Address</label>
            <input type="email" id="subscription-email" name="email" required class="w-full border border-gray-300 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="you@example.com" />
          </div>
          <div>
            <label for="subscription-whatsapp" class="block text-gray-700 font-semibold mb-1">WhatsApp Number</label>
            <input type="tel" id="subscription-whatsapp" name="whatsapp" required class="w-full border border-gray-300 rounded px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="+1234567890" />
          </div>
          <div class="flex items-center space-x-2">
            <input type="checkbox" id="subscription-terms" name="terms" checked required class="w-4 h-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500" />
            <label for="subscription-terms" class="text-gray-600 text-sm select-none">I agree to the <a href="#" class="text-indigo-600 underline">Terms and Conditions</a></label>
          </div>
          <button type="submit" class="w-full bg-indigo-600 text-white py-2 rounded-lg font-semibold hover:bg-indigo-700 transition">Subscribe</button>
        </form>
        <p id="subscription-message" class="mt-3 text-center text-sm text-green-600 hidden"></p>
      </div>
    </div>

    <script src="subscription.js"></script>

    <!-- Bookmark Button (fixed bottom left) -->
    <button
      id="bookmark-button"
      aria-label="Bookmark this page"
      class="fixed bottom-20 left-6 bg-indigo-600 text-white p-3 rounded-full shadow-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 z-50"
      title="Bookmark this page"
    >
      <span class="material-symbols-outlined">
        star
      </span>
    </button>

    <!-- Notification Popup -->
    <div
      id="bookmark-notification"
      class="fixed bottom-32 left-6 bg-green-600 text-white px-4 py-2 rounded shadow-lg opacity-0 pointer-events-none transition-opacity duration-500 z-50"
      role="alert"
      aria-live="assertive"
    >
      Product bookmarked!
    </div>

    <script type="module">
        import { REVIEWS_POPUP_AD_URL, TOP_ADS, TOP_DISPLAY_TIMES, BOTTOM_ADS, BOTTOM_DISPLAY_TIMES } from './adConfig.js';
    </script>
    <script type="module" src="./chatbot.js"></script>
    <script type="module" src="./bookmark.js"></script>

    <footer class="bg-white shadow p-4 text-center text-gray-600 text-xs max-w-screen-xl mx-auto flex flex-col items-center">
      <p class="mt-1 text-gray-500 max-w-md mx-auto">
        This site participates in the Amazon Services LLC Associates Program, an affiliate advertising program designed to provide a means for sites to earn advertising fees by advertising and linking to Amazon.com. All product prices and availability are subject to change. Product information is sourced from Amazon and other affiliate partners.
      </p>
      <div id="footer-links" class="mt-4 space-x-4">
        <a href="https://example.com/about" class="text-indigo-600 hover:underline" onclick="openLinkBehind(event, this.href)">About</a>
        <a href="https://example.com/terms" class="text-indigo-600 hover:underline" onclick="openLinkBehind(event, this.href)">Terms of Use</a>
        <a href="https://example.com/unsubscribe" class="text-indigo-600 hover:underline" onclick="openLinkBehind(event, this.href)">Unsubscribe</a>
      </div>
      <div class="mt-4 flex items-center justify-center space-x-2">
          <span>© 2024 Hygiene & Cleaning Products Affiliate Store</span>
          <img src="https://flagcdn.com/us.svg" alt="USA Flag" class="w-5 h-3 inline-block" />
      </div>
    </footer>

    <script>
      /**
       * Attempts to open a given URL in a new browser tab, ideally in the background.
       * This provides a less intrusive way to open external links.
       * If opening a new tab is blocked by the browser's popup blocker, it falls back to navigating the current tab.
       * @param {Event} event - The click event object from the anchor tag that triggered this function.
       * @param {string} url - The URL string that should be opened.
       */
      function openLinkBehind(event, url) {
        event.preventDefault(); // Prevent the browser's default action for the link (which is usually to navigate the current tab).

        // Attempt to open the specified URL in a new browser tab.
        // Using '_blank' as the window name tells the browser to open a new, unnamed tab or window.
        const newTab = window.open(url, '_blank');

        // Check if the `window.open` call successfully returned a reference to the new window/tab.
        // If a popup blocker prevented opening the new tab, `window.open` will typically return null.
        if (newTab) {
          // If the new tab was successfully opened:
          newTab.blur(); // Attempt to remove focus from the newly opened tab. This is part of trying to send it to the background.
          window.focus(); // Attempt to bring focus back to the current browser window.
           console.log(`Attempted to open link in background tab: ${url}`); // Log the action.
        } else {
            // If `window.open` returned null (likely due to a popup blocker):
            // Fall back to navigating the current browser tab to the specified URL.
             console.warn(`Failed to open link in background tab (possibly due to popup blocker). Navigating current tab directly to: ${url}`); // Log a warning about the fallback.
             window.location.href = url; // Navigate the current window's location to the URL.
        }
      }
    </script>

    <script type="module">
      // Import the VisitorCountBubble class from its module file.
      // The path './visitorCountBubble.js' is relative to the directory containing this HTML file.
      // Adjust the path if your visitorCountBubble.js file is located elsewhere (e.g., '../js/visitorCountBubble.js').
      import VisitorCountBubble from './visitorCountBubble.js'; // Make sure this path is correct relative to index.html

      // Initialize a new instance of the VisitorCountBubble.
      // The latest version of the VisitorCountBubble script is designed to append its elements (the bubble, image, tooltip)
      // directly to the document body when initialized and does NOT require a container element ID passed to the constructor.
      // Pass the desired initial visitor count (e.g., 10) as the constructor argument.
       console.log('Initializing VisitorCountBubble...');
      const visitorBubble = new VisitorCountBubble(10); // Initialize with a starting count (e.g., 10 visitors)
       console.log('VisitorCountBubble initialized.');

      // Set up a timer to periodically increment the visitor count displayed by the bubble.
      // This simulates new visitors arriving over a set time interval.
       console.log('Starting visitor count increment timer.');
      setInterval(() => {
        // Call the `increment` method on the `visitorBubble` instance.
        // This method updates the displayed count and triggers any associated animations.
        visitorBubble.increment();
         // You can uncomment the line below for more frequent console logging, showing every increment.
         // console.log('Visitor count incremented by timer.');
      }, 5000); // The interval duration in milliseconds (5000ms = 5 seconds). Adjust this value to change how often the count increases.


    </script>


    <script>
        // --- Start of main.js content ---
        // This block contains the main application logic that executes after the HTML is parsed
        // and when the window's 'load' event fires (for code within the load listener).

        // <-- IMPORTANT: Configure your Google Apps Script URL for the product data feed -->
        // This URL should point to the deployed web app of your Google Apps Script that is configured
        // to output product data (likely in JSON format) when accessed via an HTTP GET request.
        const GOOGLE_APPS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbwyKPTF5RwKNUzroHZZV1uRjuHqFPThBxAADwDGhRmWYhoJLZd49gfYOsAstX0sHHKW2Q/exec'; // <-- REPLACE with your Apps Script Deployment URL for product data (must be deployed as a web app accessible to "Anyone")

        // <-- IMPORTANT: Configure your Amazon Associates affiliate tag -->
        // This is your unique Amazon Associates Tracking ID. It will be appended to links
        // pointing to Amazon products, allowing you to earn advertising fees on qualifying purchases.
        const AMAZON_AFFILIATE_TAG = 'your-actual-affiliate-tag-20'; // <-- REPLACE with your Amazon Associates Tracking ID (e.g., yourstorename-20)

        // Global flag used to track if a video popup is currently considered "playing".
        // This is a simple mechanism to help prevent the user from opening multiple description popups simultaneously,
        // which might lead to unexpected behavior with multiple video players.
        let videoPlaying = false;

        /**
         * Asynchronously fetches product data from the configured Google Apps Script URL.
         * It uses the Fetch API to make an HTTP GET request.
         * Includes error handling for network issues and non-OK HTTP responses.
         * Also includes checks to ensure the fetched data is in the expected format (an array with content).
         * As a robust fallback, it returns a sample product array if the fetch fails, the response is empty,
         * or the fetched data appears to be in an incorrect or empty format.
         * @returns {Promise<Array<Object>>} A promise that resolves with an array of product data objects. Each object represents a product.
         */
        async function fetchProducts() {
          console.log('Attempting to fetch product data from Google Apps Script:', GOOGLE_APPS_SCRIPT_URL); // Log the URL being accessed.
          try {
            // Use the Fetch API to send an HTTP GET request to the Apps Script URL.
            const response = await fetch(GOOGLE_APPS_SCRIPT_URL);

            // Check if the HTTP response status is OK (status code between 200 and 299).
            if (!response.ok) {
              // If the response status is not OK, it indicates an HTTP error (e.g., 404, 500).
              // Throw an error with details about the HTTP status and the URL that was fetched.
              throw new Error(`HTTP error! status: ${response.status} during fetch from ${GOOGLE_APPS_SCRIPT_URL}`);
            }

            // Attempt to parse the response body as JSON.
            // If the response body is not valid JSON, the `.json()` method will throw an error.
            let products = await response.json();
            console.log('Successfully fetched product data:', products); // Log the fetched data.

            // Check if the fetched data is an array and is not empty
            if (!Array.isArray(products) || products.length === 0) {
              console.warn('Fetched data is not an array or is empty. Falling back to sample product data.'); // Log a warning if data is empty or wrong type.
              return [sampleProduct()]; // Return an array containing only the sample product as a fallback.
            }

            // Map the fetched product keys to the expected keys used in rendering
            products = products.map(p => ({
              "Product ID": p.productId || 0,
              "Category": p.productCategory || '',
              "Product Name": p.productName || '',
              "Description": p.productDescription || '',
              "Price ($)": p.productPrice || 0,
              "Retail Price ($)": p.productPriceOld || 0,
              "Image URL": p.productImageUrl || '',
              "Amazon ASIN": p.productAsin || '',
              "Stock Left": p.productFomoText ? parseInt(p.productFomoText.match(/\d+/)) || 0 : 0,
              "People Viewing": 10, // Default value, as not provided
              "Star Rating": p.productRating ? p.productRating.toString() : '4.5',
              "Is Verified Seller": false, // Placeholder, no data
              "Is Best Seller": p.productBadge === 'Best Seller',
              "Is Eco Certified": p.productBadge === 'Eco-Friendly'
            }));

            // Optional: Perform a more detailed structural validation on the fetched data.
            // Check if the first object in the 'products' array has properties that are expected and essential for creating a product card ('Product ID', 'Product Name', 'Amazon ASIN').
            // This helps catch issues if the Google Apps Script returns data in a format that doesn't match the expected structure.
            if (products.length > 0 && (!products[0].hasOwnProperty('Product ID') || !products[0].hasOwnProperty('Product Name') || !products[0].hasOwnProperty('Amazon ASIN'))) {
                 console.warn('Fetched data structure might be incorrect (missing "Product ID", "Product Name", or "Amazon ASIN" in the first item). Falling back to sample product data.'); // Log a warning about the potential format issue.
                 return [sampleProduct()]; // Fallback to sample data if the structure is unexpected.
            }

            // If the fetch was successful and the data passed basic validation, return the fetched products array.
            return products;

          } catch (error) {
            // Catch any errors that occurred during the fetch process (e.g., network connectivity issues, DNS errors, JSON parsing errors from `.json()`).
            console.error('Failed to fetch product data:', error); // Log the specific error details.
            console.warn('Using sample product data for testing due to fetch error.'); // Log that the fallback is being used.
            // Return an array containing only the sample product unconditionally when any error occurs during the fetch attempt.
            return [sampleProduct()];
          }
        }

        /**
         * Generates a sample product object with placeholder data.
         * This function is used as a fallback when the real product data cannot be fetched
         * or is in an invalid format. It demonstrates the expected structure of a product object.
         * @returns {object} A product data object populated with sample values for testing and demonstration.
         */
        function sampleProduct() {
          console.log('Generating sample product data...'); // Log that sample data is being generated.
          return {
            "Product ID": 999, // Sample unique identifier for the product.
            "Category": "Sample Category", // Sample product category.
            "Product Name": "Sample Product (Fallback)", // Sample name for the product, explicitly indicating it's a fallback.
            "Description": "This is a sample product description used when the live product feed is unavailable or empty. It demonstrates the visual layout and interactive features of a product card and its associated popups (description/video, reviews).", // Sample description text.
            "Price ($)": 9.99, // Sample price of the product.
            "Image URL": "https://via.placeholder.com/300x200?text=Sample+Product+Image", // A placeholder image URL from Placeholder.com.
            "Amazon ASIN": "B000000000", // A placeholder Amazon Standard Identification Number. Required for constructing Amazon links and Amazon Pay buttons.
            "Stock Left": 5, // Sample value for the "Stock Left" FOMO (Fear Of Missing Out) message.
            "People Viewing": 15, // Sample value for the "People Viewing" FOMO message.
            "Star Rating": "4.5", // Sample star rating (represented as a string).
            "Video URL": "https://www.youtube.com/embed/YOUR_VIDEO_ID", // <-- IMPORTANT: Replace this with a real, embeddable YouTube Video URL (e.g., from the YouTube embed share option). Make sure to add `?enablejsapi=1` at the end of the query string for YouTube API control (needed to detect when the video ends). Example: `https://www.youtube.com/embed/YOUR_VIDEO_ID?enablejsapi=1`. Placeholder URL is used for structural consistency.
             // Add other sample properties here that your `createProductCard` function might use,
             // especially for conditional display or badges. These should match the property names
             // expected by your `createProductCard` implementation.
             "Is Verified Seller": true, // Sample boolean indicating a verified seller badge.
             "Is Best Seller": true, // Sample boolean indicating a best seller badge.
             "Is Eco Certified": false, // Sample boolean indicating an eco-certified badge.
             "Retail Price ($)": 14.99 // Sample retail price for displaying a strike-through "Regular Price".
          };
        }


        /**
         * Dynamically creates an HTML div element that visually represents a product card.
         * This function constructs the DOM structure for a single product card based on the provided product data object.
         * It includes the product image (with click-to-zoom functionality), the product name, description (which is clickable to open a popup),
         * the product price, FOMO (Fear Of Missing Out) elements like stock count and viewing count, product badges (with tooltips),
         * and action buttons like "Pay with Amazon", "View on Amazon", and "View Reviews".
         * Error handling is included to return null if the input product data is fundamentally invalid or missing essential properties required to build the card.
         * @param {object} product - The product data object containing the details necessary to populate the card. Expected to have properties like 'Product ID', 'Product Name', 'Image URL', 'Price ($)', 'Amazon ASIN', and potentially others for FOMO and badges.
         * @returns {HTMLElement|null} The created product card div element as a DOM object, or null if the input product data was invalid and a card could not be generated.
         */
        function createProductCard(product) {
          console.log('Attempting to create product card for:', product ? product['Product Name'] : 'Invalid Product Data Received'); // Log the product name (or indicator if data is null/undefined).

          // Perform a validation check on essential product properties required to build the core of the card.
          // If any key property is missing, log an error and return null, indicating card creation failed for this data.
           if (!product || !product['Product ID'] || !product['Product Name'] || !product['Image URL'] || !product['Amazon ASIN'] || product['Price ($)'] === undefined) {
               console.error('Invalid product data provided to createProductCard. Missing essential properties (Product ID, Name, Image URL, ASIN, or Price). Card creation failed for:', product);
               return null; // Return null to signal that a valid card could not be generated from this input data.
           }

          // Construct the standard Amazon product page URL using the product's ASIN and the site's Amazon affiliate tag.
          const productLink = `https://www.amazon.com/dp/${product['Amazon ASIN']}?tag=${AMAZON_AFFILIATE_TAG}`;
          // The reviews link is constructed dynamically later when the reviews popup is specifically opened.
          // const reviewsLink = `https://www.amazon.com/product-reviews/${product['Amazon ASIN']}`;

          // Create the main container div element for the product card.
          const card = document.createElement('div');
          // Apply Tailwind CSS classes for styling, layout (flex column), size constraints (min/max width), snap behavior for horizontal scrolling, transitions for animations, hover effects (scale and shadow), and horizontal centering (mx-auto).
          card.className = 'product-card bg-white rounded-xl shadow-lg p-5 flex flex-col min-w-[280px] max-w-xs snap-start transition-transform transform hover:scale-105 hover:shadow-xl mx-auto';
          // Apply a specific inline style to set the height of the card, as specified in the original code's requirements.
          card.style.height = '95%';
          // Store the product's Amazon ASIN as a data attribute (`data-asin`) directly on the card element.
          // This allows for easy lookup and association between the card element and the product data later (e.g., when a button on the card is clicked).
          card.setAttribute('data-asin', product['Amazon ASIN']);

          // Create the product image element (`<img>`).
          const img = document.createElement('img');
          img.src = product['Image URL']; // Set the source URL for the image from the product data.
          img.alt = `Image of ${product['Product Name']}`; // Set the alternative text for the image. This is crucial for accessibility (screen readers).
          img.loading = 'lazy'; // Enable lazy loading: the browser will defer loading this image until the user scrolls near its location in the viewport. This improves initial page load performance.
          // Apply Tailwind CSS classes for styling (full width, fixed height, object fit to cover the area, rounded corners, shadow, transitions for effects),
          // cursor style (pointer to indicate interactivity), default z-index, and relative positioning.
          img.className = 'w-full h-40 object-cover mb-4 rounded-xl shadow transition-transform duration-300 ease-in-out cursor-pointer z-10 relative';
          img.style.zIndex = '10'; // Set a default z-index value. The z-index will be changed to a higher value when the image is zoomed.
           // Add an ARIA label to the image element to provide a descriptive label for screen readers, indicating its interactive behavior (clicking for zoom).
           img.setAttribute('aria-label', `Image of ${product['Product Name']}. Click to toggle zoom.`);


          // --- Image Zoom/Toggle Effect (controlled by click) ---
          // This set of functions implements a click-to-toggle zoom effect for the product image.
          // Clicking the image will switch between its normal size and a larger, zoomed-in state.
          // The zoomed-in state includes complex absolute positioning and an optional mouse-following pan effect.

          /**
           * Handles the process of zooming the product image in.
           * Calculates the zoomed size, desired position, applies styles for zooming, and sets up the mousemove listener for panning.
           */
          function zoomIn() {
            // Find the closest parent element with the class 'product-card'. This is necessary to get the boundaries and position of the card relative to which the image will be positioned when zoomed.
            const cardElement = img.closest('.product-card');
             // Only proceed with the complex zoom logic if the image is successfully found within a product card element.
             // If not found (shouldn't happen in this structure, but as a safeguard), apply a simpler scale-only zoom.
            if (cardElement) {
              const cardRect = cardElement.getBoundingClientRect(); // Get the dimensions and position of the product card relative to the viewport.
              const imgRect = img.getBoundingClientRect(); // Get the dimensions and position of the image relative to the viewport.
              const zoomScale = 1.6; // Define the scale factor for how much larger the image should become when zoomed.
              const zoomedHeight = imgRect.height * zoomScale; // Calculate the image height after scaling.
              const zoomedWidth = imgRect.width * zoomScale; // Calculate the image width after scaling.


              // Calculate the translation offsets (in pixels) needed to move the image's current top-left corner
              // so that it aligns precisely with the product card's original top-left corner in the viewport.
              // We want the zoomed image's new top position to match the card's top position in the viewport.
              const targetTop = cardRect.top; // The desired final top position (matching the card's top).
              const currentTop = imgRect.top; // The image's current top position.
              let topOffset = targetTop - currentTop; // The vertical offset required to move from current top to target top.

               // We want the zoomed image's new left position to match the card's left position in the viewport.
               const targetLeft = cardRect.left; // The desired final left position (matching the card's left).
               const currentLeft = imgRect.left; // The image's current left position.
              let leftOffset = targetLeft - currentLeft; // The horizontal offset required to move from current left to target left.


              // Constrain the calculated offsets (`topOffset`, `leftOffset`). This is crucial to ensure that
              // the edges of the zoomed image do not extend beyond the boundaries defined by the product card's
              // original position and the zoomed image's dimensions. This prevents the zoomed image from
              // appearing off-screen if the product card is positioned near the edge of the browser window.

              // Vertical constraint: Ensure the zoomed image's top and bottom edges stay within the card's original top and bottom.
              // `maxTopOffset` is the maximum positive value `topOffset` can have before the zoomed image's bottom edge moves above the card's bottom edge.
              const maxTopOffset = cardRect.height - zoomedHeight;
              if (maxTopOffset >= 0) { // Apply constraint only if the zoomed image is taller than or equal to the card's height.
                 if (topOffset > maxTopOffset) topOffset = maxTopOffset; // If calculated offset moves zoomed bottom above card bottom, cap it at `maxTopOffset`.
                 if (topOffset < 0) topOffset = 0; // If calculated offset moves zoomed top above card top, cap it at 0.
              } else { // If the zoomed image is shorter than the card's height.
                 // In this scenario, the zoomed image's top can be aligned with the card's top (offset 0) without its bottom exceeding the card's bottom.
                 // Ensure `topOffset` is not negative if the card top is visible.
                 if (topOffset < 0) topOffset = 0;
                 // Optional enhancement: Could calculate an offset to vertically center the shorter zoomed image within the card if desired: `topOffset = (cardRect.height - zoomedHeight) / 2;`
              }

              // Horizontal constraint: Ensure the zoomed image's left and right edges stay within the card's original left and right.
               const maxLeftOffset = cardRect.width - zoomedWidth;
               if (maxLeftOffset >= 0) { // Apply constraint only if the zoomed image is wider than or equal to the card's width.
                 if (leftOffset > maxLeftOffset) leftOffset = maxLeftOffset; // If calculated offset moves zoomed right past card right, cap it at `maxLeftOffset`.
                 if (leftOffset < 0) leftOffset = 0; // If calculated offset moves zoomed left past card left, cap it at 0.
               } else { // If the zoomed image is narrower than the card's width.
                 // In this case, the zoomed image's left can be aligned with the card's left (offset 0) without its right exceeding the card's right.
                 // Ensure `leftOffset` is not negative if the card left is visible.
                 if (leftOffset < 0) leftOffset = 0;
                 // Optional enhancement: Could calculate an offset to horizontally center the narrower zoomed image within the card if desired: `leftOffset = (cardRect.width - zoomedWidth) / 2;`
               }

               // Apply the calculated initial position offsets (`topOffset`, `leftOffset`) to the image's inline styles (`top` and `left`).
               // Also, set the CSS `transition` property to enable smooth animation of these changes, as well as changes to `transform` and `box-shadow`.
              img.style.transition = 'top 0.4s ease, left 0.4s ease, transform 0.4s ease, box-shadow 0.4s ease'; // Apply transition to multiple properties.
              img.style.top = `${topOffset}px`; // Set the image's top position relative to its original position within the card's flow.
              img.style.left = `${leftOffset}px`; // Set the image's left position relative to its original position within the card's flow.


              // Add a `mousemove` event listener to the image element ONLY when it is in the zoomed-in state.
              // This listener enables the panning effect: moving the image slightly as the mouse cursor moves over it.
              /**
               * Handles the panning movement of the zoomed image based on the mouse cursor's position over the image.
               * Calculates translation values to shift the image so the area under the mouse cursor stays relatively centered.
               * @param {MouseEvent} e - The mousemove event object.
               */
              function onMouseMove(e) {
                // Get the current dimensions and position of the *zoomed* image in the viewport. These values update as the user pans.
                const currentImgRect = img.getBoundingClientRect();
                 // Calculate the mouse cursor's position relative to the top-left corner of the *zoomed* image.
                const mouseX = e.clientX - currentImgRect.left;
                const mouseY = e.clientY - currentImgRect.top;

                // Calculate the mouse cursor's position as a percentage within the *zoomed* image's dimensions (ranging from 0 to 1, where 0 is left/top edge and 1 is right/bottom edge).
                const percentX = mouseX / currentImgRect.width;
                const percentY = mouseY / currentImgRect.height;

                 // Determine the maximum range available for translation (panning).
                 // This range is based on how much the *zoomed* image's dimensions exceed the dimensions of the *card's original area*.
                 const boundsX = Math.max(0, zoomedWidth - cardRect.width); // How much wider the zoomed image is than the card's original width.
                 const boundsY = Math.max(0, zoomedHeight - cardRect.height); // How much taller the zoomed image is than the card's original height.

                 // Calculate the translation values (in pixels) needed to pan the image.
                 // The goal is to pan the image in the opposite direction of the mouse movement relative to the center.
                 // If the mouse is at the left edge (percentX = 0), `(0.5 - 0) * boundsX = 0.5 * boundsX`. We translate right by half the excess width.
                 // If the mouse is at the right edge (percentX = 1), `(0.5 - 1) * boundsX = -0.5 * boundsX`. We translate left by half the excess width.
                 // If the mouse is in the center (percentX = 0.5), `(0.5 - 0.5) * boundsX = 0`. No horizontal translation relative to the initial offset.
                const translateX = (0.5 - percentX) * boundsX;
                const translateY = (0.5 - percentY) * boundsY;

                 // Apply the zoom scale and the mouse-based translation using the CSS `transform` property.
                 // The `translate()` function is applied *after* the `scale()` function in the transform property. This means the translation values are applied relative to the *scaled* dimensions of the image.
                 // This `transform` style is applied *in addition* to the `top` and `left` positioning styles set previously in the `zoomIn` function.
                 img.style.transform = `scale(${zoomScale}) translate(${translateX}px, ${translateY}px)`;


              }
              // Add the `mousemove` event listener to the image element. This listener will be active as long as the mouse cursor is over the zoomed image.
              img.addEventListener('mousemove', onMouseMove);

               // Set a slightly faster transition duration specifically for the `transform` property (0.1s) during mousemove.
               // This makes the image panning feel more responsive and smooth as the user moves their mouse. Keep the other transitions at 0.4s.
              img.style.transition = 'top 0.4s ease, left 0.4s ease, transform 0.1s ease, box-shadow 0.4s ease';


              // Store a reference to the specific `onMouseMove` function instance that was just created and added as a listener.
              // Storing this reference (e.g., as `img._onMouseMove`) is necessary to be able to remove the *exact* same listener later in the `zoomOut` function.
              img._onMouseMove = onMouseMove;

            } else {
                 // Fallback: If the image was not found within a product card element (which should not happen in this HTML structure, but as a safeguard),
                 // apply a simpler scale-only zoom effect without the complex positioning or panning.
                img.style.transition = 'transform 0.4s ease, box-shadow 0.4s ease'; // Apply transition to scale and shadow.
                img.style.transform = 'scale(1.6)'; // Apply scale transformation.
                 console.warn('Image element is not a child of an element with class "product-card". Applying basic scale zoom without complex positioning/panning.');
            }

             // Apply general CSS styles that should be active on the image element when it is in the zoomed state.
             // These styles are applied regardless of whether the complex positioning logic based on the parent card was used.
            img.style.zIndex = '9999'; // Set a very high z-index. This layers the zoomed image on top of most other content on the page, ensuring it's fully visible.
            img.style.position = 'absolute'; // Change the positioning context to 'absolute'. This is required for applying z-index effectively and for using the `top` and `left` positioning properties relative to the nearest positioned ancestor (or the initial containing block, which is typically the viewport/document if no positioned ancestor exists).
            img.style.boxShadow = '0 10px 20px rgba(0,0,0,0.3)'; // Apply a prominent shadow to the zoomed image to visually separate it from the content behind it.
            img.style.borderRadius = '1rem'; // Apply a slightly larger border radius to the image when it's zoomed.
            img.style.cursor = 'zoom-out'; // Change the mouse cursor style to indicate that clicking the image will zoom it back out.
             img._isZoomed = true; // Set a custom boolean flag property on the image element. This flag helps track the current zoom state (`true` means zoomed in).
          }

          /**
           * Handles zooming the product image out and resetting its styles and event listeners
           * back to their normal state.
           */
          function zoomOut() {
             // Reset the image's `transform` property. This reverts the image back to its original scale (1)
             // and removes any translation applied for panning (translate(0, 0)).
            img.style.transform = 'scale(1) translate(0, 0)';

             // Reset the image's positioning, layering, and appearance styles back to their default state within the product card.
            img.style.zIndex = '10'; // Revert the z-index back to its original value (lower than the zoomed state).
            img.style.position = 'relative'; // Revert the positioning context back to 'relative'. This places the image back into the normal document flow of its parent container (the product card).
            img.style.top = 'auto'; // Reset the explicit 'top' positioning style, allowing it to be determined by normal document flow.
            img.style.left = 'auto'; // Reset the explicit 'left' positioning style, allowing it to be determined by normal document flow.
            img.style.boxShadow = 'none'; // Remove the applied shadow.
            img.style.borderRadius = '0.75rem'; // Revert the border radius back to its original value.

             // Set the CSS `transition` property to enable smooth animation of the styles when zooming out.
            img.style.transition = 'transform 0.4s ease, box-shadow 0.4s ease, top 0.4s ease, left 0.4s ease'; // Apply transition to multiple properties.
            img.style.cursor = 'zoom-in'; // Change the mouse cursor style back to indicate that clicking will zoom in.

            // Remove the `mousemove` event listener that was added during the `zoomIn` state.
            // Use the stored reference (`img._onMouseMove`) to ensure that the *exact* function instance that was added is removed.
            if (img._onMouseMove) { // Check if the stored reference exists.
              img.removeEventListener('mousemove', img._onMouseMove); // Remove the listener.
              delete img._onMouseMove; // Clean up the stored reference property from the image element.
               console.log('Removed mousemove listener from image.');
            }
             img._isZoomed = false; // Reset the custom boolean flag to indicate the image is no longer zoomed in.
          }

           // Add a `click` event listener to the image element.
           // This listener calls either `zoomIn` or `zoomOut` based on the current state, toggling the zoom effect.
           img.addEventListener('click', () => {
               console.log('Image clicked. Checking zoom state.');
               // Check the custom `_isZoomed` flag to determine the current state of the image.
               if (img._isZoomed) { // If the flag is true (image is currently zoomed in)...
                   zoomOut(); // ...call the `zoomOut` function.
                   console.log('Image was zoomed, called zoomOut.');
               } else { // If the flag is false (image is not currently zoomed in)...
                   zoomIn(); // ...call the `zoomIn` function.
                   console.log('Image was not zoomed, called zoomIn.');
               }
               // The `_isZoomed` flag is updated within `zoomIn` and `zoomOut`.
           });

           // Optional: If you also want the zoom effect to be triggered by mouse hover (in addition to or instead of click),
           // uncomment the lines below. Note that hover effects can be less user-friendly on touch devices and
           // the complex mousemove logic might behave differently.
           // img.addEventListener('mouseenter', zoomIn); // Call zoomIn when mouse enters the image area.
           // img.addEventListener('mouseleave', zoomOut); // Call zoomOut when mouse leaves the image area.

          // --- End Image Zoom/Toggle Effect ---


          // Create the heading element (`<h2>`) for the product name.
          const name = document.createElement('h2');
          name.textContent = product['Product Name']; // Set the text content to the product's name.
          // Apply Tailwind CSS classes for styling: font size, weight, bottom margin, text color, text truncation (to prevent overflow), and centering.
          name.className = 'text-lg font-semibold mb-1 text-gray-900 truncate text-center';

          // Create the paragraph element (`<p>`) for the product description.
          const description = document.createElement('p');
          // Apply Tailwind CSS classes for styling: text color, flex-grow (allows element to take available space in flex container), cursor (pointer to indicate clickable), underline (to hint it's interactive), line-clamp-3 (limits description to 3 lines), and text alignment.
          description.className = 'text-gray-600 flex-grow cursor-pointer underline line-clamp-3 text-center text-sm';
          description.style.minHeight = '4.5rem'; // Set a minimum height to provide a consistent space for the description in each card, even if the text is very short. (approx. 3 lines of text).
          description.textContent = product['Description']; // Set the text content to the product's description.
          // Add a click event listener to the description paragraph. When clicked, it will open the description/video popup for this product.
          description.addEventListener('click', () => openDescriptionPopup(product));


          // Create the paragraph element (`<p>`) for the product price display.
          const price = document.createElement('p');
          // Apply Tailwind CSS classes for styling: text color, font weight (extra bold), top margin, font size, and text alignment.
          price.className = 'text-indigo-700 font-extrabold mt-2 text-lg text-center';
          // Get the retail price from the product data. If the 'Retail Price ($)' property is not found, calculate a sample retail price
          // by multiplying the current price by 1.5 and formatting it to 2 decimal places. Use "N/A" if the current price is also unavailable.
          const retailPrice = product['Retail Price ($)'] || (product['Price ($)'] ? (parseFloat(product['Price ($)']) * 1.5).toFixed(2) : 'N/A');
           // Get the current price from the product data. If the 'Price ($)' property is undefined, use "N/A".
           const currentPrice = product['Price ($)'] !== undefined ? `$${product['Price ($)']}` : 'N/A';
          // Set the inner HTML of the price paragraph. It includes the retail price with a strike-through (`<sub>` with `line-through` class) and the current price.
          price.innerHTML = `<sub class="line-through text-gray-500 mr-2">Reg. Price: $${retailPrice}</sub> ${currentPrice}`;


          // --- FOMO microcopy elements (Stock Left and People Viewing) ---
          // These elements are designed to display information that creates a sense of urgency (low stock)
          // or popularity (many people viewing). In a dynamic application, these values would ideally
          // be updated in real-time or near-real-time.

          // Create a span element to hold the numeric value of the stock left count.
          const qtyLeftSpan = document.createElement('span'); // Renamed from `qtyLeft` to `qtyLeftSpan` to avoid potential conflict if `qtyLeft` were used differently.
          qtyLeftSpan.id = `qty-left-${product['Product ID']}`; // Assign a unique ID to this span based on the product ID. This ID could be used later if you need to update this specific count dynamically.
          // Get the stock count from the product data. Default to 0 if the 'Stock Left' property is undefined or if its value is the placeholder -999.
          const stockCount = (product['Stock Left'] !== undefined && product['Stock Left'] !== -999) ? product['Stock Left'] : 0;
          qtyLeftSpan.textContent = stockCount; // Set the visible text content to the stock number.
          qtyLeftSpan.className = 'text-red-600 font-semibold'; // Apply styling (red color, bold font).

          // Create a span element for the text label that follows the stock count number (" left in stock!").
          const qtyLeftTextSpan = document.createElement('span'); // Renamed.
          qtyLeftTextSpan.id = `qty-left-text-${product['Product ID']}`; // Assign a unique ID.
          qtyLeftTextSpan.textContent = ' left in stock!'; // Set the text label.
          qtyLeftTextSpan.className = 'text-red-600 font-semibold'; // Apply styling.

          // Create a paragraph element (`<p>`) to contain the complete Stock Left message (number + text label).
          const stockLeftElement = document.createElement('p'); // Renamed from `stockLeft`.
          // Apply Tailwind CSS classes for styling: text color (red), font weight, text alignment, top margin, flex layout (to arrange child spans inline), and spacing between spans.
          stockLeftElement.className = 'text-red-600 font-semibold text-center mt-1 text-sm flex justify-center space-x-1';
           // Conditional display logic: Only show the "X left in stock!" message structure if the calculated stock count is greater than 0.
          if (stockCount > 0) {
             stockLeftElement.appendChild(qtyLeftSpan); // Append the span with the stock number.
             stockLeftElement.appendChild(qtyLeftTextSpan); // Append the span with the text label.
             console.log(`Displaying stock message for ${product['Product Name']}: ${stockCount} left.`);
          } else {
              // If stock is 0 or less, display a simple "Currently out of stock." message instead.
              stockLeftElement.textContent = 'Currently out of stock.';
              // Change the text color from red to gray to indicate that the item is not available.
              stockLeftElement.classList.remove('text-red-600');
              stockLeftElement.classList.add('text-gray-500');
              console.log(`Displaying out of stock message for ${product['Product Name']}.`);
          }


          // Create a span element to hold the numeric value of the people viewing count.
          const viewQtySpan = document.createElement('span'); // Renamed.
          viewQtySpan.id = `view-qty-${product['Product ID']}`; // Assign a unique ID.
          // Get the viewing count from the product data. Default to '10' (as a string) if the 'People Viewing' property is undefined.
          const viewingCount = product['People Viewing'] !== undefined ? product['People Viewing'] : '10';
          viewQtySpan.textContent = viewingCount; // Set the visible text content to the number.
          viewQtySpan.className = 'text-red-600 font-semibold'; // Apply styling.

          // Create a span element for the text label that follows the viewing count number (" people viewing now").
          const viewQtyTextSpan = document.createElement('span'); // Renamed.
          viewQtyTextSpan.id = `view-qty-text-${product['Product ID']}`; // Assign a unique ID.
          viewQtyTextSpan.textContent = ' people viewing now';
          viewQtyTextSpan.className = 'text-red-600 font-semibold'; // Apply styling.

          // Create a paragraph element (`<p>`) to contain the complete People Viewing message (number + text label).
          const peopleViewingElement = document.createElement('p'); // Renamed from `peopleViewing`.
          // Apply Tailwind CSS classes for styling: text color (red), font weight, text alignment, top margin, flex layout (to arrange child spans inline), and spacing between spans.
          peopleViewingElement.className = 'text-red-600 font-semibold text-center mt-1 text-sm flex justify-center space-x-1';
           // Conditional display logic: Only show the "X people viewing now" message structure if the viewing count, when parsed as an integer, is greater than 0.
           if (parseInt(viewingCount) > 0) { // Parse as integer for numeric check.
               peopleViewingElement.appendChild(viewQtySpan); // Append the span with the viewing number.
               peopleViewingElement.appendChild(viewQtyTextSpan); // Append the span with the text label.
               console.log(`Displaying viewing count message for ${product['Product Name']}: ${viewingCount} viewing now.`);
           } else {
               // If viewing count is 0 or less, hide the entire message element by setting its display style to 'none'.
               peopleViewingElement.style.display = 'none';
                console.log(`Hiding viewing count message for ${product['Product Name']} (count is 0 or less).`);
           }

           // --- End FOMO microcopy elements ---


          // Create a container div for product badges (e.g., Verified Seller, Best Seller).
          const badgesContainer = document.createElement('div');
          // Apply Tailwind CSS classes for layout: flex container, centering children, spacing between children, allowing children to wrap to the next line if needed (flex-wrap), and adding a small gap between wrapped items.
          badgesContainer.className = 'flex justify-center space-x-2 mt-2 flex-wrap gap-1'; // Allow wrapping and add small gap


          /**
           * Helper function to create a badge element.
           * A badge is a small piece of text (e.g., "Best Seller") with an optional tooltip that appears on hover or focus.
           * @param {string} text - The primary text string to display directly on the badge.
           * @param {string} tooltip - The detailed text string to display inside the tooltip when it appears.
           * @returns {HTMLElement} The created span element representing the badge. This span contains the tooltip element as a child.
           */
          function createBadge(text, tooltip) {
            const badge = document.createElement('span'); // Use a span element for the badge.
            badge.textContent = text; // Set the visible text of the badge.
            // Apply Tailwind CSS classes for styling: background color (light gray), text color (dark gray), horizontal and vertical padding, rounded shape (full circle/pill shape), font size (extra small), font weight (semi-bold), cursor style (help cursor on hover), and relative positioning (necessary for the absolute-positioned tooltip child). Also an inline-block display to work with positioning.
            badge.className = 'bg-gray-300 text-gray-800 px-2 py-0.5 rounded-full text-xs font-semibold cursor-help relative inline-block'; // Use inline-block to allow relative positioning.
            // Add accessibility attributes: make the badge focusable using the keyboard (tabindex) and provide the tooltip text as an ARIA label for screen readers.
            badge.setAttribute('tabindex', '0'); // Allows the element to receive keyboard focus.
            badge.setAttribute('aria-label', tooltip); // Provides a descriptive label for accessibility tools, explaining the badge or its tooltip.
            badge.setAttribute('role', 'tooltip'); // Indicate that this element serves as a tooltip target or container (less common for target, more for tooltip itself, but provides context).

            // Create the tooltip div element that will be shown when the badge is hovered or focused.
            const tooltipEl = document.createElement('div');
            // Apply Tailwind and custom styles for the tooltip's appearance (background, text color, text size, rounded shape, shadow, padding), position (absolutely positioned relative to the badge, centered horizontally above it), transition for fading in/out, pointer events (disabled so the tooltip itself doesn't block clicks), whitespace handling (prevents text wrapping), and layering (high z-index to ensure it's on top).
            tooltipEl.className = 'absolute bottom-full left-1/2 transform -translate-x-1/2 mb-2 px-2 py-1 bg-gray-800 text-white text-xs rounded shadow-md opacity-0 pointer-events-none transition-opacity duration-300 whitespace-nowrap z-50'; // Initially hidden (opacity 0), does not capture mouse events (pointer-events none), high z-index to be on top.
            tooltipEl.textContent = tooltip; // Set the text content of the tooltip.


            // Add event listeners to the badge element to control the visibility (opacity) of the tooltip on mouse hover and keyboard focus.
            badge.addEventListener('mouseenter', () => { tooltipEl.style.opacity = '1'; }); // Set opacity to 1 to show tooltip when the mouse enters the badge area.
            badge.addEventListener('mouseleave', () => { tooltipEl.style.opacity = '0'; }); // Set opacity to 0 to hide tooltip when the mouse leaves the badge area.
            badge.addEventListener('focus', () => { tooltipEl.style.opacity = '1'; }); // Set opacity to 1 to show tooltip when the badge receives keyboard focus (e.g., via Tab key).
            badge.addEventListener('blur', () => { tooltipEl.style.opacity = '0'; }); // Set opacity to 0 to hide tooltip when the badge loses keyboard focus.

            // Append the created tooltip div element as a child of the badge element.
            // This makes the tooltip's position relative to the badge and keeps them grouped structurally.
            badge.appendChild(tooltipEl);
            return badge; // Return the complete badge element (the span containing the tooltip div).
          }

          // Add badges to the `badgesContainer` based on specific properties of the product data.
          // This makes the badges dynamic, only appearing if the product data indicates they apply.
           // Check for boolean or truthy values in product data for badge properties. Adjust property names ('Is Verified Seller', 'Is Best Seller', 'Is Eco Certified') to match your actual data structure.
           if (product['Is Verified Seller']) { // If the product has 'Is Verified Seller' property and it's truthy...
               badgesContainer.appendChild(createBadge('✅ Verified Seller', 'This seller is verified and trusted on Amazon.')); // ...create and append the Verified Seller badge.
           }
           if (product['Is Best Seller']) { // If the product has 'Is Best Seller' property and it's truthy...
               badgesContainer.appendChild(createBadge('🌟 Best Seller', 'This product is a best seller in its category.')); // ...create and append the Best Seller badge.
           }
           if (product['Is Eco Certified']) { // If the product has 'Is Eco Certified' property and it's truthy...
               badgesContainer.appendChild(createBadge('🌱 Eco-Certified', 'This product meets certain eco-friendly standards.')); // ...create and append the Eco-Certified badge.
           }
            // Add a default "Available" badge if *none* of the specific conditional badges were added.
            // This ensures there's always at least one badge indicating availability.
           if (!badgesContainer.hasChildNodes()) { // Check if the container is empty.
               badgesContainer.appendChild(createBadge('🛍️ Available', 'This product is available for purchase.')); // Create and append the default "Available" badge.
           }


          // Create a container div for the action buttons located at the bottom of the product card.
          const buttonsContainer = document.createElement('div');
          // Apply Tailwind CSS classes for styling and layout: top margin, flex container, centering children horizontally, spacing between children, allowing children to wrap to the next line, and adding a gap between wrapped items.
          buttonsContainer.className = 'mt-4 flex space-x-2 justify-center flex-wrap gap-2';


          // --- Create the "Pay with Amazon" Button ---
          // This button integrates with the Amazon Pay SDK to initiate a secure checkout process directly from your site.
          // IMPORTANT: To make this button fully functional, you MUST have a backend implementation that securely
          // interacts with the Amazon Pay API to create a checkout session payload and signature for each transaction.
          const payButton = document.createElement('button'); // Use a button element for interactive click action.
          // Assign a unique ID to this button. The Amazon Pay SDK's `renderButton` function uses this ID as a selector
          // to bind the Amazon Pay functionality to this specific button element in the DOM.
          payButton.id = `AmazonPayButton-${product['Product ID']}`; // Construct a unique ID using the product ID.
          // Apply Tailwind CSS classes for styling: flex-grow (allows button to expand), max-width constraint, rounded shape, shadow, overflow (important if logo is larger than button), cursor, flex layout (to center the logo inside), background color (Amber/Gold-like, matching common Amazon Pay button colors), transition for hover/focus effects, and padding. Added focus styles.
          payButton.className = 'flex-grow max-w-[140px] rounded-xl shadow-md overflow-hidden cursor-pointer flex items-center justify-center bg-amber-400 hover:bg-amber-500 transition p-2 md:p-3 focus:outline-none focus:ring-2 focus:ring-amber-500';


          // Create an image element (`<img>`) for the Amazon Pay logo to be displayed inside the button.
          const amazonPayLogo = document.createElement('img');
          // Set the `src` attribute to a standard URL provided by Amazon for the Pay button logo image.
          // Choose the logo variant (dark or light) that provides the best contrast with the chosen button color (`buttonColor` in the Amazon Pay config).
          // Example URL for a dark logo (suitable for light/gold buttons): `https://images-na.ssl-images-amazon.com/images/G/01/amazonpay/contact-us/amazon-pay-logo-dark._CB485932824_.png`
          // Example URL for a light logo (suitable for dark gray buttons): `https://images-na.ssl-images-amazon.com/images/G/01/AmazonPay/landing/03/2017/amazon-pay-logo-light._V530839464_.png`
          amazonPayLogo.src = 'https://images-na.ssl-images-amazon.com/images/G/01/amazonpay/contact-us/amazon-pay-logo-dark._CB485932824_.png'; // <-- REPLACE if using a different button color scheme or logo variant
          amazonPayLogo.alt = 'Pay with Amazon'; // Set alt text for accessibility.
          amazonPayLogo.className = 'h-6 md:h-7 object-contain'; // Apply classes for height (responsive) and object fit to ensure the logo scales correctly within the button.

          // Append the Amazon Pay logo image to the button element.
          payButton.appendChild(amazonPayLogo);

          // Add a click event listener to the "Pay with Amazon" button.
          // IMPORTANT: The Amazon Pay SDK's `renderButton` function, which is called later after the card is in the DOM,
          // will typically override or handle the primary click action of this button to initiate the Amazon Pay checkout flow.
          // This listener serves primarily as a fallback action (e.g., simply redirecting the user to the standard Amazon product page)
          // in case the Amazon Pay SDK fails to load or bind correctly, or as an alternative action depending on your desired user flow.
          payButton.addEventListener('click', () => {
            console.log(`"Pay with Amazon" button clicked for ASIN: ${product['Amazon ASIN']}. Initiating fallback redirect to Amazon.`); // Log the click.
            // Fallback redirection: Open the standard Amazon product page in a new tab using the affiliate link.
             window.open(`https://www.amazon.com/dp/${product['Amazon ASIN']}?tag=${AMAZON_AFFILIATE_TAG}`, '_blank', 'noopener noreferrer'); // Use rel="noopener noreferrer" for security with target="_blank".
             console.log('Opening Amazon product page as a fallback/alternative action.');
          });
          // The main Amazon Pay checkout functionality is attached to this button element (identified by its ID)
          // by the `amazon.Pay.renderButton()` call, which happens within the `renderProducts` function after the card is added to the DOM.


          // --- Create the "View on Amazon" Button ---
          // This is a standard link button that directs the user to the product's page on Amazon.
          const viewButton = document.createElement('a'); // Use an anchor tag (`<a>`) because it's fundamentally a navigation link.
          viewButton.href = productLink; // Set the link's destination to the Amazon product page URL (which includes the affiliate tag).
          viewButton.target = '_blank'; // Open the link in a new browser tab.
          viewButton.rel = 'noopener noreferrer'; // Recommended security measure when using target="_blank" to prevent potential "tabnabbing" attacks.
          viewButton.textContent = '🔍 View on Amazon'; // Set the visible text of the link/button, including a magnifying glass emoji.
          // Apply Tailwind CSS classes for styling: background color (blue gradient), text color (white), vertical/horizontal padding, rounded shape (xl), hover effect (darker gradient), flex-grow (allows expansion), max-width constraint, text alignment, font weight, shadow, font size (responsive), and focus styles.
          viewButton.className = 'bg-blue-600 text-white py-2 px-4 rounded-xl hover:bg-blue-700 flex-grow max-w-xs text-center font-semibold shadow-md text-sm md:text-base focus:outline-none focus:ring-2 focus:ring-blue-500';


          // --- Create the "View Reviews" Button ---
          // This button opens a popup modal that displays the product reviews, typically embedded from Amazon.
          const reviewsButton = document.createElement('button'); // Use a button element for interactive click action.
          reviewsButton.type = 'button'; // Explicitly set the button type to "button" to prevent default form submission behavior if this button is accidentally placed inside a form element.
          // Get the star rating from the product data. If the 'Star Rating' property is not found or is undefined, default to the string '4.7'.
          const starRating = product['Star Rating'] || '4.7';
          // Determine the button's background color class based on the star rating value (example logic).
          // Green background for ratings 4.0 and above, Yellow background for ratings below 4.0. Includes hover and focus ring styles within the class string.
          const ratingColorClass = parseFloat(starRating) >= 4.0 ? 'bg-green-600 hover:bg-green-700 focus:ring-green-500' : 'bg-yellow-600 hover:bg-yellow-700 focus:ring-yellow-500';

          // Set the button's inner HTML content. It includes a star emoji (`⭐`) followed by the star rating number.
          reviewsButton.innerHTML = `⭐ ${starRating}`; // Use innerHTML to render the emoji and text.
          // Apply Tailwind CSS classes for styling: combine the determined `ratingColorClass` with standard classes for text color (white), padding, rounded shape (xl), flex-grow, max-width constraint, text alignment, font weight, shadow, font size (small), and general focus styles.
          reviewsButton.className = `${ratingColorClass} text-white py-1 px-3 rounded-xl flex-grow max-w-[120px] text-center font-semibold shadow-md text-sm focus:outline-none focus:ring-2`; // Note: focus:ring-2 is generic, the color is expected from ratingColorClass.
          // Add a click event listener to the "View Reviews" button. When clicked, it calls the `openReviewsPopup` function, passing the current product data.
          reviewsButton.addEventListener('click', () => openReviewsPopup(product));


          // --- Append all created elements to the main product card container ---
          card.appendChild(img); // Append the product image element.
          card.appendChild(name); // Append the product name heading.
          card.appendChild(description); // Append the product description paragraph (clickable).
          card.appendChild(price); // Append the price paragraph.
          // Append the FOMO elements if they were created (conditional based on stock/viewing count > 0).
          // These are the paragraphs containing the number and text label.
          card.appendChild(stockLeftElement); // Append the Stock Left FOMO message paragraph.
          card.appendChild(peopleViewingElement); // Append the People Viewing FOMO message paragraph.
          card.appendChild(badgesContainer); // Append the container div holding the badges.

          // Append the individual button elements to their container div (`buttonsContainer`).
          buttonsContainer.appendChild(payButton); // Append the "Pay with Amazon" button.
          buttonsContainer.appendChild(viewButton); // Append the "View on Amazon" link.
          buttonsContainer.appendChild(reviewsButton); // Append the "View Reviews" button.
          // Finally, append the entire `buttonsContainer` div to the main product card container.
          card.appendChild(buttonsContainer);

          console.log('Product card created successfully for:', product['Product Name']); // Log success after appending all children.
          return card; // Return the complete product card DOM element. This element will then be added to the product slider container by `renderProducts`.
        }


        /**
         * Asynchronously fetches product data using the `WorkspaceProducts` function.
         * After the data is retrieved (or the sample fallback is used), it iterates through the products,
         * creates an HTML product card for each using `createProductCard`, and appends these cards to the
         * `#product-slider` container element in the HTML.
         * Finally, it attempts to initialize the Amazon Pay buttons for all rendered cards using the Amazon Pay Widgets SDK.
         */
        async function renderProducts() {
          console.log('renderProducts called. Initiating product data fetch and rendering process.'); // Log the start of the function.
          // Await the result of the `WorkspaceProducts` function. Execution pauses here until the promise returned by `WorkspaceProducts` resolves (either with real data, sample data, or null/error).
          const products = await fetchProducts();
          console.log('Products data retrieved (fetched or sample). Ready for card creation and rendering:', products); // Log the data obtained.

          // Get the DOM element that serves as the container for the product cards (the product slider div).
          const container = document.getElementById('product-slider');
          // Check if the container element was successfully found in the DOM. This is essential.
          if (!container) {
            console.error('Product slider container element (#product-slider) not found in the DOM. Cannot render products.'); // Log a critical error if the container is missing.
            return; // Exit the function immediately if the container is not found.
          }
          // Clear any existing content inside the product slider container before adding new product cards.
          // This prevents duplicate cards if the function were called multiple times or if placeholder content was present.
          container.innerHTML = '';

          // Check if the 'products' variable is valid (is an array) and if it contains any elements.
          if (!products || !Array.isArray(products) || products.length === 0) {
            // If no products are available (array is null/undefined, not an array, or empty),
            // display a user-friendly message inside the container.
            container.textContent = 'No products available at the moment. Please check back later.'; // Set the text content of the container.
            container.className = 'text-center text-gray-600 p-4'; // Apply Tailwind classes to center and style the message, including padding.
            console.warn('No products available to render after fetch/fallback. Displaying "no products" message.');
            return; // Exit the function as there are no products to iterate over and render.
          }

          // Iterate over each product data object in the 'products' array.
          products.forEach(product => {
            // For each product object, call the `createProductCard` function to generate its corresponding HTML element.
            const card = createProductCard(product);
            // Check if the `createProductCard` function successfully returned a valid DOM element.
            // `createProductCard` returns null if the input product data is invalid.
            if (card) {
              // If the card element was successfully created, append it as a child to the product slider container.
              container.appendChild(card);
               console.log(`Appended product card for "${product['Product Name']}" to #product-slider.`); // Log success for each card.
            } else {
              // If `createProductCard` returned null, log an error indicating that card creation failed for this specific product data.
              console.error('Skipping rendering for invalid product data. createProductCard returned null for:', product);
            }
          });

          // Log the total number of product cards that were successfully added to the container.
          console.log(`Rendering complete. Appended ${container.childElementCount} product card(s) into #product-slider.`);

          // Optional: Call a function to start an auto-scrolling animation for the product slider container.
          // You need to implement the `startAutoScroll` function separately and include it in your script.
          // startAutoScroll(container); // Uncomment this line if you have the `startAutoScroll` function defined.

          // --- Amazon Pay Button Rendering ---
          // This section initializes the Amazon Pay buttons using the Amazon Pay Widgets SDK (`window.amazon.Pay`).
          // This step MUST be called *after* the HTML product cards (which contain the button elements) have been added to the DOM,
          // because the SDK needs to find the button elements by their IDs.
          // It checks if the Amazon Pay SDK is loaded and available before proceeding.
          // IMPORTANT: The configuration passed to `amazon.Pay.renderButton`, especially the `createCheckoutSessionConfig`,
          // requires values (`payloadJSON`, `signature`, `algorithm`) that MUST be generated SECURELY on YOUR BACKEND SERVER
          // for EACH unique checkout attempt to prevent fraud and ensure data integrity. You cannot hardcode these or generate them on the frontend for a production site.
          if (window.amazon && window.amazon.Pay) { // Check if the `amazon` object and its `Pay` property exist on the window object. This confirms the SDK is loaded.
              console.log('Amazon Pay SDK (window.amazon.Pay) detected. Attempting to render buttons for rendered product cards.'); // Log that the SDK is available.
            // Iterate over the original products array again. We can use the product data to get the button ID.
            products.forEach(product => {
              // Before attempting to render the Amazon Pay button, ensure the product data contains the necessary properties
              // ('Product ID', 'Amazon ASIN') to construct the unique button ID and initiate checkout.
              if (product['Product ID'] && product['Amazon ASIN']) {
                  // Construct the unique ID of the button element that was created in `createProductCard` for this product.
                  const buttonId = `AmazonPayButton-${product['Product ID']}`;
                  // Find the corresponding button element in the DOM using its constructed ID.
                  const buttonContainer = document.getElementById(buttonId);

                  // Check if the button element was successfully found in the DOM.
                  if (buttonContainer) {
                    try {
                         // Call the Amazon Pay SDK's `renderButton` function.
                         // This function binds the Amazon Pay checkout functionality to the specified button element.
                         // The first argument is a CSS selector string (using '#' followed by the element's ID).
                         // The second argument is a configuration object containing your Amazon Pay account details and checkout session information.
                         window.amazon.Pay.renderButton(`#${buttonId}`, {
                          merchantId: 'YOUR_MERCHANT_ID', // <-- IMPORTANT: REPLACE with your actual Amazon Pay Merchant ID. This is a unique identifier for your Amazon Pay account.
                          publicKeyId: 'YOUR_PUBLIC_KEY_ID', // <-- IMPORTANT: REPLACE with your actual Public Key ID from Amazon Pay. This is used to verify the signature.
                          ledgerCurrency: 'USD', // <-- IMPORTANT: REPLACE with the currency of the transaction (e.g., 'USD', 'EUR', 'GBP', 'JPY'). Must match the currency used in your checkout session configuration.
                          checkoutLanguage: 'en_US', // <-- IMPORTANT: REPLACE with the desired language and region for the Amazon Pay checkout experience (e.g., 'en_US', 'en_GB', 'de_DE', 'ja_JP').
                          productType: 'PayAndShip', // <-- Specify the type of checkout: 'PayAndShip' is typically used for physical goods that require shipping; 'Checkout' is used for digital goods or services.
                          placement: 'Cart', // <-- Indicate where the button is placed on your site (e.g., 'Cart', 'Product', 'Home', 'Other'). This helps Amazon optimize the user experience. Recommended.
                          buttonColor: 'Gold', // <-- Set the visual color of the button ('Gold', 'DarkGray', 'LightGray', 'Indigo', 'DarkBlue'). Choose one that matches your site's design.
                          // The `createCheckoutSessionConfig` object is REQUIRED for initiating the checkout process when using the Widgets.js SDK.
                          // The properties within this object (`payloadJSON`, `signature`, `algorithm`) contain details about the transaction and MUST be generated SECURELY on YOUR BACKEND SERVER
                          // for EACH unique checkout attempt. Generating these on the frontend is insecure and will not work in production.
                          createCheckoutSessionConfig: {
                            payloadJSON: 'REPLACE_WITH_SECURELY_GENERATED_PAYLOAD_JSON', // <-- IMPORTANT: Replace this placeholder string with the *actual JSON payload string* generated by your backend server for this specific checkout session. This payload contains details like the return URLs, order amount, etc.
                            signature: 'REPLACE_WITH_SECURELY_GENERATED_SIGNATURE', // <-- IMPORTANT: Replace this placeholder string with the *actual signature string* generated by your backend server. This signature is created by signing the `payloadJSON` using your Amazon Pay private key.
                            algorithm: 'AMZN-PAY-RSASSA-PSS-V2' // <-- Specify the signing algorithm used by your backend to generate the signature. This must match the algorithm used in your backend implementation. Options are 'AMZN-PAY-RSASSA-PSS-V2' (recommended) or 'AMZN-PAY-RSASSA-PSS'. Required.
                             // If using the older 'AMZN-PAY-RSASSA-PSS' algorithm, you might need to include your publicKeyId here as well (it's optional for V2):
                             // publicKeyId: 'YOUR_PUBLIC_KEY_ID'
                          }
                        });
                         console.log(`Amazon Pay button rendered successfully for ASIN: ${product['Amazon ASIN']} (ID: ${buttonId}).`); // Log successful rendering.
                    } catch (error) {
                        // Catch and log any specific errors that might occur during the Amazon Pay SDK's `renderButton` call.
                        console.error(`Error rendering Amazon Pay button for ASIN ${product['Amazon ASIN']} (ID: ${buttonId}):`, error); // Log the error details.
                        // If rendering fails for a button, it's good practice to hide that specific button or provide alternative feedback to the user.
                        if(buttonContainer) { // Check if the button element exists before attempting to hide it.
                            buttonContainer.style.display = 'none'; // Hide the button element.
                            console.warn(`Hid Amazon Pay button for ASIN ${product['Amazon ASIN']} due to render error.`);
                        }
                    }
                  } else {
                      // Log a warning if the expected button element was not found in the DOM after product card creation.
                      // This might happen if there was an error in `createProductCard` for this product.
                      console.warn(`Amazon Pay button container element not found in the DOM for ASIN ${product['Amazon ASIN']} (Expected ID: ${buttonId}). Skipping Amazon Pay render for this button.`);
                  }
              } else {
                   // Log a warning if a product object in the data is missing the essential 'Product ID' or 'Amazon ASIN' needed to construct the button ID and configure Amazon Pay.
                   console.warn(`Skipping Amazon Pay button render for product with missing 'Product ID' or 'Amazon ASIN':`, product);
              }
            });
             console.log('Amazon Pay render button calls completed for all products.'); // Log completion of the rendering loop.
          } else {
            // Log a warning if the Amazon Pay SDK object (`window.amazon.Pay`) is not found at all.
            // This indicates that the SDK script (`Widgets.js`) likely failed to load from the CDN.
            console.warn('Amazon Pay SDK (window.amazon.Pay) not detected or fully loaded. Amazon Pay buttons will not be rendered or function.');
             // As a fallback, you might want to explicitly hide all elements in the DOM that are intended to be Amazon Pay buttons if the SDK isn't available.
             document.querySelectorAll('[id^="AmazonPayButton-"]').forEach(btn => { // Select all elements whose ID starts with "AmazonPayButton-".
                 if (btn) { // Check if the element exists (though querySelectorAll returns a NodeList, checking individual elements is safe).
                      btn.style.display = 'none'; // Hide the element.
                 }
             });
             console.warn('Hid all elements with IDs starting with "AmazonPayButton-" as the Amazon Pay SDK is not loaded.');
          }
          // --- End Amazon Pay Button Rendering ---

        }


        /**
         * Opens the popup modal (#popup-modal) to display product details, specifically including a video player
         * and product information below the video.
         * This function manages the loading of the YouTube Iframe API (if needed) and sets up event listeners
         * for the video player to detect when the video ends or encounters an error.
         * Product details are rendered and shown after the video finishes playing or if video loading/playback fails.
         * @param {object} product - The product data object. Expected to contain 'Video URL' (the embeddable URL for the video) and 'Amazon ASIN' (for linking to product details/buttons on the card).
         */
        function openDescriptionPopup(product) {
          console.log('Attempting to open description popup for:', product ? product['Product Name'] : 'Invalid Product Data Received'); // Log the product name or indicator if data is invalid.

           // Basic validation: Check if the product data is valid and contains the essential properties
           // required for this specific popup (a Video URL and the Amazon ASIN).
           if (!product || !product['Video URL'] || !product['Amazon ASIN']) {
               console.error('Invalid product data provided for description popup. Missing Product object, "Video URL", or "Amazon ASIN". Cannot proceed with video display.', product);
               // Fallback behavior: If video data is missing or invalid, attempt to show just the product details immediately in the popup
               // without trying to load the video. This provides some information to the user.
               showProductDetailsInPopup(product); // Call the function to render and show product details in the popup.
                const popup = document.getElementById('popup-modal'); // Get the main popup modal element.
                // Show the modal itself, even if there's no video to display.
                if (popup) { // Check if the modal element exists.
                     popup.classList.remove('hidden'); // Remove the 'hidden' class to make the modal visible.
                     console.log('Showing description popup with details only (due to missing/invalid video data).');
                } else {
                     console.error('Popup modal element (#popup-modal) not found for fallback display of details.'); // Log error if modal is missing.
                }
               return; // Exit the function here as we cannot proceed with loading a video.
           }


          // Use the global `videoPlaying` flag as a simple lock to prevent opening multiple description popups simultaneously.
          // This helps avoid issues with multiple video players conflicting or unexpected state behavior.
          if (videoPlaying) {
              console.log('A video popup is already considered active. Preventing a new description popup from opening.');
              return; // Exit the function immediately if the flag is true.
          }

          // Get the main popup modal element and its content area element from the DOM.
          const popup = document.getElementById('popup-modal');
          const popupContent = document.getElementById('popup-content');
          // Check if these essential DOM elements were successfully found.
          if (!popup || !popupContent) {
              console.error('Popup modal elements (#popup-modal or #popup-content) not found in the DOM. Cannot open description popup.'); // Log a critical error if elements are missing.
              return; // Exit the function.
          }

           // Clear any previous content that might be present inside the popup content area.
          popupContent.innerHTML = '';
           // Set the ARIA label for the modal dialog. This attribute should reference the ID of the element that serves as the modal's title (e.g., a heading).
          popup.setAttribute('aria-labelledby', 'popup-title');


          // --- Create and Append Video Element (Iframe for YouTube Embed) ---
          // Create a wrapper div for the iframe. Using a wrapper allows for responsive aspect ratio control using CSS utilities (like Tailwind's `aspect-w`/`aspect-h`).
          const videoWrapper = document.createElement('div');
          videoWrapper.className = 'aspect-w-16 aspect-h-9 mb-4 w-full max-w-full'; // Apply classes for 16:9 aspect ratio, bottom margin, and width.
           videoWrapper.id = 'popup-video-wrapper'; // Assign a unique ID to the wrapper for potential later reference.

          // Create the iframe element (`<iframe>`), which will embed the video player (e.g., from YouTube).
          const iframe = document.createElement('iframe');
          // <-- IMPORTANT: Set the iframe's `src` attribute to the *embeddable* URL of the video -->
          // You must get the embed URL from the video hosting service (e.g., YouTube's "Share" -> "Embed" option).
          // If using YouTube and you need to control the player via the API (e.g., detect video end), you *must* add `?enablejsapi=1` at the end of the query string parameters.
          // This code attempts to append `?enablejsapi=1` if it's not already present.
          const videoUrl = product['Video URL'].includes('?') ? product['Video URL'] + '&enablejsapi=1' : product['Video URL'] + '?enablejsapi=1'; // Append enablejsapi=1 safely, handling existing query params.
          iframe.src = videoUrl; // Set the iframe's source URL.
          iframe.title = `Promotional Video for ${product['Product Name']}`; // Set an accessible title for the iframe. This is important for screen readers.
          // Set the `allow` attribute to grant the iframe necessary permissions (accelerometer, autoplay, clipboard, encrypted-media, gyroscope, picture-in-picture).
          iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
          iframe.allowFullscreen = true; // Allow the video player within the iframe to be viewed in fullscreen mode.
          // Apply Tailwind CSS classes for styling: full width within its parent wrapper, a fixed height (adjust as needed), and rounded corners.
          iframe.className = 'w-full h-64 rounded'; // Full width within wrapper, fixed height (64 units = 16rem = 256px).
          iframe.setAttribute('frameborder', '0'); // Explicitly set the `frameborder` attribute to '0' to remove the default border around the iframe.
          iframe.setAttribute('loading', 'lazy'); // Use lazy loading for the iframe content. The browser will defer loading the iframe until it is near the viewport.

          // Append the created iframe element as a child of the video wrapper div.
          videoWrapper.appendChild(iframe);
          // Append the video wrapper div (containing the iframe) to the main popup content area.
          popupContent.appendChild(videoWrapper);
          // --- End Video Element ---

          // --- Create and Append Product Details Area ---
          // Create a dedicated div element that will serve as the container for the product details (name, description, price, etc.).
          // This area is typically displayed below the video and can be initially hidden.
           const productDetailsArea = document.createElement('div');
           productDetailsArea.id = 'popup-product-details'; // Assign a unique ID to this element.
           productDetailsArea.className = 'hidden'; // Initially hide this area using Tailwind's 'hidden' class (`display: none;`).
           // The specific content (image, name, description, etc.) will be added dynamically to this area by the `showProductDetailsInPopup` function.

           // Append the dedicated product details area div to the main popup content area.
           popupContent.appendChild(productDetailsArea);
          // --- End Product Details Area ---


          // --- YouTube Iframe API Setup ---
          // This block contains the logic to load the YouTube Iframe API script and set up a player instance
          // linked to the embedded iframe. It uses the API to listen for events like video playback ending.
          // The YouTube API script (loaded from Google's servers) calls a global function named `onYouTubeIframeAPIReady`
          // when it has finished loading. We define this global function here.
          const loadYouTubeAPI = () => {
              // Define the required global function `onYouTubeIframeAPIReady`. This function is called by the YouTube API script when it finishes loading.
              window.onYouTubeIframeAPIReady = function() {
                  console.log('YouTube Iframe API script has loaded and is ready (`window.onYouTubeIframeAPIReady` executed).');
                  // Attempt to create a new YouTube Player instance.
                  // This links the JavaScript API to the embedded iframe player.
                  // The constructor takes the iframe element or its ID and an options object (including event listeners).
                  try {
                       const player = new window.YT.Player(iframe, { // Use `window.YT.Player` to be explicit about the global object.
                           // The 'events' object contains callback functions that are executed when specific player events occur.
                          events: {
                              // 'onStateChange' event: Fires whenever the player's state changes (e.g., unstarted, playing, paused, buffering, ended, cued).
                              'onStateChange': function(event) {
                                  console.log('YouTube Player state changed. New state data:', event.data); // Log the state change data.
                                  // Check the event data to determine the new state:
                                  // `window.YT.PlayerState.ENDED` (value 0): The video has finished playing.
                                  if (event.data === window.YT.PlayerState.ENDED) {
                                      console.log('Video playback has ended successfully. Proceeding to show product details.');
                                      videoPlaying = false; // Reset the global flag as the video is no longer playing.
                                      showProductDetailsInPopup(product); // Call the function to render and show product details below the video.

                                      // Logic to show the "View on Amazon" button on the original product card in the slider.
                                      // Find the specific product card element in the main content area using its 'data-asin' attribute.
                                       const productCardElement = document.querySelector(`.product-card[data-asin="${product['Amazon ASIN']}"]`);
                                       if (productCardElement) { // Check if the corresponding product card element was found.
                                            // Find the anchor tag link within this specific card that points to the Amazon DP (product page) and opens in a new tab.
                                            const viewBtn = productCardElement.querySelector('a[href*="amazon.com/dp/"][target="_blank"]');
                                            if (viewBtn) { // Check if the "View on Amazon" button element was found within the card.
                                                 console.log('Found corresponding product card. Showing "View on Amazon" button after video ends.');
                                                 viewBtn.classList.remove('hidden'); // Remove the Tailwind 'hidden' class to make the button visible (if it was initially hidden).
                                            } else {
                                                 console.warn('Could not find the "View on Amazon" button element within the product card.');
                                            }
                                            // Optional: You might also want to hide the "Pay with Amazon" button here if you intend for "View on Amazon" to be the sole primary action after the video.
                                            // const payBtn = productCardElement.querySelector('button[id^="AmazonPayButton-"]');
                                            // if (payBtn) payBtn.classList.add('hidden');
                                       } else {
                                            console.warn('Corresponding product card element not found in the DOM using data-asin. Cannot show "View on Amazon" button on card.');
                                       }
                                  }
                                  // `window.YT.PlayerState.PLAYING` (value 1): The video is currently playing.
                                  else if (event.data === window.YT.PlayerState.PLAYING) {
                                       videoPlaying = true; // Set the global flag to true as the video is now playing.
                                       console.log('Video is now playing.');
                                  }
                                   // You can add handling for other potential states if needed:
                                  // `window.YT.PlayerState.BUFFERING` (3), `window.YT.PlayerState.PAUSED` (2), `window.YT.PlayerState.CUED` (5), `window.YT.PlayerState.UNSTARTED` (-1)
                                  else {
                                       // console.log('Video state is:', event.data); // Uncomment for logging other states.
                                  }
                              },
                              // 'onError' event: Fires if the player encounters an error (e.g., video not found, invalid parameters, playback issue).
                               'onError': function(event) {
                                   console.error('YouTube Player error occurred. Error data:', event.data, '(Refer to YouTube Iframe API documentation for error code details: https://developers.google.com/youtube/iframe_api_reference#onError)'); // Log the error details.
                                   videoPlaying = false; // Reset the flag on error, as playback is not successful.
                                   // Even if there's an error, attempt to show product details as a fallback so the user gets some information.
                                   showProductDetailsInPopup(product);
                                   // Optionally hide the problematic iframe and display a user-friendly error message within the popup.
                                   if(iframe) iframe.style.display = 'none'; // Hide the iframe element.
                                   const errorMsg = document.createElement('p'); // Create a paragraph element for the error message.
                                   errorMsg.textContent = 'Could not load video. Please try viewing the product on Amazon.'; // Set the error message text.
                                   errorMsg.className = 'text-red-600 text-center mb-4'; // Apply styling.
                                    // Append the error message to the video wrapper div or the main popup content area as a fallback location.
                                    if(videoWrapper) videoWrapper.appendChild(errorMsg);
                                     else if (popupContent) popupContent.appendChild(errorMsg); // Fallback append location.
                               }
                               // Other player events like 'onReady' (when the player is ready to receive commands) can be added here if needed.
                               // 'onReady': function(event) { console.log('YouTube Player is ready.'); }
                          }
                      });
                       console.log('YouTube Player instance created successfully and event listeners attached for iframe.'); // Log successful player creation.
                  } catch (error) {
                       // Catch and log any errors that occur specifically during the creation of the `YT.Player` instance.
                       console.error('Error creating YouTube Player instance:', error); // Log the error details.
                       videoPlaying = false; // Reset the flag on creation error.
                       // As a fallback, show product details if player initialization fails.
                       showProductDetailsInPopup(product);
                       // Hide the iframe and show an error message in this scenario as well.
                       if(iframe) iframe.style.display = 'none';
                        const errorMsg = document.createElement('p');
                       errorMsg.textContent = 'Could not initialize video player. Please try viewing the product on Amazon.';
                       errorMsg.className = 'text-red-600 text-center mb-4';
                       if(videoWrapper) videoWrapper.appendChild(errorMsg);
                        else if (popupContent) popupContent.appendChild(errorMsg);
                  }
              };

              // Check if the YouTube Iframe API script (which defines `window.YT`) has already been loaded into the browser.
              if (!window.YT) {
                  console.log('YouTube Iframe API script not yet loaded. Loading script dynamically...'); // Log that the script is about to be loaded.
                  const tag = document.createElement('script'); // Create a new script element.
                  // Set the `src` attribute of the script element to the standard URL for the YouTube Iframe API script.
                  // This URL is provided by Google/YouTube. Using 'https://www.youtube.com/iframe_api' is a common and reliable way to load it.
                  tag.src = "https://www.youtube.com/iframe_api"; // <-- CORRECT standard YouTube Iframe API script URL.
                  // Find the first existing script tag in the document head.
                  const firstScriptTag = document.getElementsByTagName('script')[0];
                   // Insert the newly created API script tag into the document head *before* the first existing script tag.
                   // This is the recommended method for inserting the YouTube API script to ensure it initializes correctly.
                   if(firstScriptTag && firstScriptTag.parentNode) { // Check if a first script tag and its parent node exist.
                       firstScriptTag.parentNode.insertBefore(tag, firstScriptTag); // Insert the new tag before the first existing tag.
                        console.log('YouTube Iframe API script tag inserted into document head.'); // Log successful insertion.
                   } else {
                       // Fallback: If no script tags were found in the head, append the API script tag directly to the document body.
                       document.body.appendChild(tag); // Append to the body.
                        console.warn('No existing script tags found in head. Appending YouTube Iframe API script to document body as fallback.'); // Log the fallback action.
                   }
              } else {
                  // If the YouTube Iframe API script is already loaded (meaning `window.YT` exists),
                  // call the `onYouTubeIframeAPIReady` function directly. This function will then proceed to
                  // create the player and set up its event listeners immediately without waiting for the script to load again.
                  console.log('YouTube Iframe API already loaded. Calling window.onYouTubeIframeAPIReady directly.');
                  window.onYouTubeIframeAPIReady();
              }
          };

          // Initiate the process of loading the YouTube API script and setting up the player by calling the `loadYouTubeAPI` helper function.
          loadYouTubeAPI();
          // --- End YouTube Iframe API Setup ---


           // Show the main popup modal itself by removing the 'hidden' class.
           // The modal is initially hidden by its CSS class (`.hidden`).
          popup.classList.remove('hidden');
          console.log('Description popup modal displayed.');

          // Optional: Uncomment the line below if you want the product details area
          // to be visible immediately below the video when the popup opens, instead of
          // only after the video finishes playing or if video loading fails.
           // showProductDetailsInPopup(product);

        }

        /**
         * Renders the product details content (title, image, description, price, FOMO, buy button)
         * into a specified target DOM element within the popup modal.
         * This function is a helper used by `openDescriptionPopup` (after video or on video error)
         * and potentially as a direct fallback if no video data is available.
         * @param {HTMLElement} targetElement - The DOM element where the product details should be rendered (e.g., the dedicated `#popup-product-details` div).
         * @param {object} product - The product data object containing the details to display.
         */
         function renderDetailsContent(targetElement, product) {
             // Ensure the target element is valid before attempting to append children.
             if (!targetElement) {
                 console.error('Invalid target element provided to renderDetailsContent. Cannot render product details.');
                 return; // Exit if the target is invalid.
             }
              console.log('Rendering product details elements into target element:', targetElement); // Log the target element.

              // Add a title or heading for the product information section within the details area.
             const detailsTitle = document.createElement('h3'); // Create an h3 heading.
             detailsTitle.className = 'text-lg font-semibold mb-2 text-gray-800'; // Apply styling.
             detailsTitle.textContent = 'Product Information'; // Set the text content.
             targetElement.appendChild(detailsTitle); // Append the title heading to the target element.


            // Create and append the product image element within the details section.
             const img = document.createElement('img'); // Create an img element.
             img.src = product['Image URL']; // Set the image source URL.
             img.alt = `Image of ${product['Product Name']}`; // Set descriptive alt text for accessibility.
             // Apply Tailwind CSS classes for styling: size (fixed width and height), object fit (cover), rounded corners, shadow, and floating left with right margin.
             img.className = 'w-40 h-40 object-cover mb-4 rounded-xl shadow float-left mr-4'; // Fixed size, float left with margin.
             targetElement.appendChild(img); // Append the image to the target element.


            // Create and append the product name heading element.
            const title = document.createElement('h2'); // Create an h2 heading for the product name.
            title.className = 'text-xl font-semibold mb-2'; // Apply styling.
            title.textContent = product['Product Name']; // Set the text content to the product name.
            targetElement.appendChild(title); // Append the name heading.


            // Create and append the product description paragraph element.
            const desc = document.createElement('p'); // Create a paragraph element.
            desc.className = 'mb-4 text-gray-700'; // Apply styling with bottom margin and text color.
            desc.textContent = product['Description']; // Set the text content to the product description.
            targetElement.appendChild(desc); // Append the description.


            // Create and append a clearfix element. This is important to clear the `float: left` applied to the image
            // so that subsequent block-level elements (like the price, FOMO, buy button) start below the floated image
            // and do not wrap around it in an undesirable layout.
             const clearDiv = document.createElement('div'); // Create a div element.
             clearDiv.className = 'clearfix'; // Apply the `clearfix` utility class. Ensure the CSS rule for `.clearfix` is defined (either in a stylesheet or injected).
             targetElement.appendChild(clearDiv); // Append the clear div after the floated image and its sibling elements.


            // Create and append the product price paragraph element.
            const price = document.createElement('p'); // Create a paragraph element.
            price.className = 'text-indigo-700 font-bold mb-4 text-lg'; // Apply styling.
            // Set the text content to display the price. Include a label ("Price:") and use a fallback ("N/A") if the price data is undefined.
            price.textContent = `Price: $${product['Price ($)'] !== undefined ? product['Price ($)'] : 'N/A'}`; // Include label and handle undefined price.
            targetElement.appendChild(price); // Append the price paragraph.


             // --- Optional: Add FOMO microcopy (Stock Left and People Viewing) to the popup details as well ---
             // These elements display urgency/popularity information within the popup for the user.

             // Create and append elements for the stock status message.
             const stockStatus = document.createElement('p'); // Create a paragraph.
             stockStatus.className = 'text-sm text-red-600 mb-2'; // Apply styling.
             // Get the stock count from product data, defaulting to 0 if undefined or the placeholder -999.
             const stockCount = (product['Stock Left'] !== undefined && product['Stock Left'] !== -999) ? product['Stock Left'] : 0;
             // Set the text content based on the stock count.
             stockStatus.textContent = stockCount > 0 ? `Only ${stockCount} left in stock!` : 'Currently out of stock.';
              // Change the text color to gray if the item is out of stock.
              if (stockCount <= 0) stockStatus.classList.replace('text-red-600', 'text-gray-500');
             targetElement.appendChild(stockStatus); // Append the stock status paragraph.


             // Create and append elements for the viewing status message.
             const viewingStatus = document.createElement('p'); // Create a paragraph.
             viewingStatus.className = 'text-sm text-red-600 mb-4'; // Apply styling.
             // Get the viewing count from product data, defaulting to '...' (as a string) if undefined.
             const viewingCount = product['People Viewing'] !== undefined ? product['People Viewing'] : '...';
             // Set the text content to display the viewing count message.
             viewingStatus.textContent = `${viewingCount} people viewing now`;
             targetElement.appendChild(viewingStatus); // Append the viewing status paragraph.
             // --- End Optional FOMO in Popup ---


            // Create and append the "Buy on Amazon" button/link within the details area.
            const buyBtn = document.createElement('a'); // Use an anchor tag (`<a>`) for an external link.
            buyBtn.href = `https://www.amazon.com/dp/${product['Amazon ASIN']}?tag=${AMAZON_AFFILIATE_TAG}`; // Set the link URL to the Amazon product page, including the affiliate tag.
            buyBtn.target = '_blank'; // Open the link in a new browser tab.
            buyBtn.rel = 'noopener noreferrer'; // Add recommended security attributes when using `target="_blank"`.
            // Apply Tailwind CSS classes for styling: background color, text color, padding, rounded shape, hover effect, inline-block display (to sit nicely in the flow), text alignment, font weight, transition, and focus styles.
            buyBtn.className = 'bg-indigo-600 text-white py-2 px-4 rounded-lg hover:bg-indigo-700 inline-block text-center font-semibold transition focus:outline-none focus:ring-2 focus:ring-indigo-500';
            buyBtn.textContent = 'Buy on Amazon'; // Set the text content of the link/button.
            targetElement.appendChild(buyBtn); // Append the buy button link to the target element.

             console.log('Product details elements rendered into target element.'); // Log completion of rendering details.
         }


        /**
         * Opens the popup modal (#popup-modal) to display product reviews from Amazon.
         * This function first shows an advertisement image within the popup for a set duration.
         * After the ad duration expires, it clears the ad content and loads an iframe embedding
         * the Amazon product reviews page for the specific product using its ASIN.
         * @param {object} product - The product data object. Expected to contain the 'Amazon ASIN'.
         */
        function openReviewsPopup(product) {
          console.log('Attempting to open reviews popup for:', product ? product['Product Name'] : 'Invalid Product Data Received'); // Log attempt.

           // Basic validation: Check if the product data is valid and contains the necessary Amazon ASIN property, which is required to construct the reviews URL.
           if (!product || !product['Amazon ASIN']) {
               console.error('Invalid product data provided for reviews popup. Missing Product object or "Amazon ASIN". Cannot load reviews.', product);
               // If data is invalid, display an error message directly in the popup content area as a fallback.
                const popup = document.getElementById('popup-modal'); // Get the modal.
                const popupContent = document.getElementById('popup-content'); // Get the content area.
                 if(popupContent) { // Check if the content area exists.
                     popupContent.innerHTML = ''; // Clear any previous content.
                     // Display an error message to the user within the popup.
                     popupContent.innerHTML = '<p class="text-red-600 text-center">Cannot load reviews for this product (missing product identifier).</p>';
                      // Show the modal itself, even if there's an error message.
                      if(popup) {
                           popup.classList.remove('hidden'); // Make the modal visible.
                           console.log('Reviews popup shown with error message (missing ASIN).');
                      } else {
                           console.error('Popup modal element (#popup-modal) not found for error display fallback.'); // Log error if modal is missing.
                      }
                 } else {
                     console.error('Popup content element (#popup-content) not found. Cannot display reviews error message fallback.'); // Log error if content area is missing.
                 }
               return; // Exit the function here as we cannot load reviews with invalid data.
           }


          // Get the main popup modal element and its content area element from the DOM.
          const popup = document.getElementById('popup-modal');
          const popupContent = document.getElementById('popup-content');
           // Check if these essential DOM elements were successfully found.
           if (!popup || !popupContent) {
              console.error('Popup modal elements (#popup-modal or #popup-content) not found in the DOM. Cannot open reviews popup.'); // Log a critical error if elements are missing.
              return; // Exit the function.
           }

          // Clear any previous content that might be present inside the popup content area.
          popupContent.innerHTML = '';
          // Set the ARIA label for the modal dialog, referencing the title element that will be added.
          popup.setAttribute('aria-labelledby', 'popup-title');


          // --- Display Advertisement Image First ---
          // Create an image element (`<img>`) to display the advertisement within the popup.
          const adImage = document.createElement('img'); // Create an img element.
          // <-- IMPORTANT: Set the `src` attribute to the actual URL of your advertisement image -->
          // This image will be shown for a short period before the reviews load.
          adImage.src = 'https://via.placeholder.com/600x200?text=Sponsored+Ad+Image'; // <-- REPLACE with your ad image URL.
          adImage.alt = 'Sponsored Advertisement'; // Set alt text for accessibility.
          // Apply Tailwind CSS classes for styling: full width, rounded corners, bottom margin.
          adImage.className = 'w-full rounded mb-4';
           adImage.id = 'reviews-popup-ad'; // Assign a unique ID for potential later reference (e.g., if you need to remove it explicitly).

          // Append the advertisement image element to the popup content area.
          popupContent.appendChild(adImage);

           // Add a title or heading that is displayed above the ad image and transitions to the reviews title.
           const adTitle = document.createElement('h2'); // Create an h2 heading.
           adTitle.id = 'popup-title'; // Assign ID. This ID is referenced by the modal's `aria-labelledby` attribute.
           adTitle.className = 'text-xl font-semibold mb-2 text-center'; // Apply styling.
           adTitle.textContent = 'Loading Reviews...'; // Set the text content (indicates that reviews are being loaded).
           popupContent.appendChild(adTitle); // Append the title heading.


           // --- Show the Popup Modal ---
           // Make the popup modal itself visible by removing the 'hidden' class.
           // The modal is initially hidden via its CSS class (`.hidden`).
          popup.classList.remove('hidden');
           console.log('Reviews popup modal displayed with initial ad.');


          // --- Schedule Replacement of Ad with Reviews Iframe ---
          // Define the duration for which the advertisement image should be displayed (in milliseconds) before it is replaced by the reviews iframe.
          const adDisplayDuration = 3000; // 3 seconds (Adjusted from 30 seconds in a previous version for faster testing/demo cycles).
          console.log(`Advertisement will be displayed for ${adDisplayDuration / 1000} seconds before attempting to load reviews.`);

          // Use `setTimeout` to delay the execution of the code block that replaces the ad content with the reviews iframe.
          setTimeout(() => {
             console.log('Ad display duration ended. Attempting to load reviews iframe.');
            // Clear the content area by setting its innerHTML to an empty string.
            // This removes the ad image and the "Loading Reviews..." title.
            popupContent.innerHTML = '';

            // Add a new title or heading for the reviews section that replaces the ad title.
             const reviewsTitle = document.createElement('h2'); // Create an h2 heading for the reviews section.
             reviewsTitle.id = 'popup-title'; // Assign the same ID as the previous title, referenced by `aria-labelledby`.
             reviewsTitle.className = 'text-xl font-semibold mb-2'; // Apply styling.
             reviewsTitle.textContent = `${product['Product Name']} - Reviews`; // Set the text content to the product name followed by "- Reviews".
             popupContent.appendChild(reviewsTitle); // Append the reviews title heading.


            // Create and append the iframe element (`<iframe>`) to embed the Amazon product reviews page.
            const iframe = document.createElement('iframe'); // Create an iframe element.
            // Set the iframe's `src` attribute to the URL of the Amazon product reviews page.
            // This URL is constructed using the product's Amazon ASIN.
            // IMPORTANT: Be aware that Amazon (like many websites) might use security headers (such as X-Frame-Options)
            // to prevent their pages from being embedded in iframes on external websites for security reasons.
            // If the iframe fails to load the content (appears blank or shows a "refused to connect" error),
            // this is likely due to such headers. In that case, you might need to provide a direct link
            // to the reviews page on Amazon instead of embedding it in an iframe.
            iframe.src = `https://www.amazon.com/product-reviews/${product['Amazon ASIN']}`; // Set the iframe source URL.
            // Apply Tailwind CSS classes for styling: full width, a fixed height (adjust as needed), rounded corners, and a border.
            iframe.className = 'w-full h-96 rounded border'; // Full width, fixed height (96 units = 24rem = 384px), border.
            iframe.title = `Reviews for ${product['Product Name']}`; // Set an accessible title for the iframe.
            iframe.setAttribute('frameborder', '0'); // Explicitly set the `frameborder` attribute to '0'.
            iframe.setAttribute('loading', 'lazy'); // Use lazy loading for the iframe content.

            // Add an error event listener to the iframe. This can help detect if the iframe fails to load its content (e.g., due to X-Frame-Options headers).
            iframe.onerror = () => {
                 console.error('Failed to load reviews iframe. This might be due to Amazon preventing embedding (e.g., X-Frame-Options header).'); // Log the error.
                 // Optionally, you can display a user-friendly message to the user if the iframe fails to load.
                 const errorMsg = document.createElement('p'); // Create a paragraph for the error message.
                 errorMsg.textContent = 'Could not load reviews directly here. Please click the link below to view reviews on Amazon.'; // Set error message text.
                 errorMsg.className = 'text-red-600 text-center mt-4'; // Apply styling.
                  if(popupContent) { // Check if the content area exists before appending.
                       popupContent.appendChild(errorMsg); // Append the error message paragraph.
                       // Add a direct link to the Amazon reviews page as an alternative if embedding fails.
                       const amazonReviewLink = document.createElement('a'); // Create an anchor tag.
                       amazonReviewLink.href = `https://www.amazon.com/product-reviews/${product['Amazon ASIN']}`; // Set the link URL.
                       amazonReviewLink.textContent = 'View Reviews on Amazon'; // Set the link text.
                       amazonReviewLink.target = '_blank'; // Open in a new tab.
                       amazonReviewLink.rel = 'noopener noreferrer'; // Recommended security attributes.
                       amazonReviewLink.className = 'text-blue-600 hover:underline ml-2'; // Apply styling.
                       errorMsg.appendChild(amazonReviewLink); // Append the link as a child of the error message paragraph.
                  }
            };

            // Append the created iframe element to the popup content area.
            popupContent.appendChild(iframe);
             console.log('Reviews iframe added to popup content after ad delay.'); // Log completion.

          }, adDisplayDuration); // This code block (replacing ad with iframe) will execute after the specified `adDisplayDuration` has passed.
        }

        /**
         * Closes the main popup modal (#popup-modal).
         * This function is typically called when the user clicks the close button or clicks the background overlay.
         * It hides the modal by adding the 'hidden' class.
         * It also attempts to stop playback of any embedded YouTube video within the modal by sending a postMessage command to the iframe.
         * Finally, it resets the global `videoPlaying` flag.
         */
        function closePopup() {
          console.log('Attempting to close popup modal.'); // Log the start of the close operation.
          const popup = document.getElementById('popup-modal'); // Get the popup modal element from the DOM.

           // Check if the popup modal element was successfully found.
           if (popup) {
               // Add the 'hidden' class back to the modal element. Assuming Tailwind's 'hidden' class sets `display: none;`, this will effectively hide the modal from view and remove it from the document layout.
               popup.classList.add('hidden');
               console.log('Popup modal hidden via closePopup function.'); // Log that the modal is hidden.

               // --- Attempt to Stop Embedded YouTube Video Playback ---
               // Find any iframe element that is a child of the popup modal.
               // Then, filter these iframes to identify ones that are likely YouTube embeds by checking if their `src` attribute contains a specific pattern associated with YouTube embed URLs.
               const iframe = popup.querySelector('iframe[src*="youtube.com/embed"]'); // Look for iframes whose `src` attribute contains this pattern (adjusted placeholder for check). This assumes YouTube embed URLs will contain this pattern.
               // Check if a potential YouTube iframe was found AND if its `contentWindow` property exists AND if the `postMessage` method is available on the `contentWindow`. `postMessage` is the method used to communicate with the iframe's content script, which is necessary for controlling the YouTube player via the API.
               if (iframe && iframe.contentWindow && typeof iframe.contentWindow.postMessage === 'function') {
                   // If a potential YouTube iframe is found and supports postMessage, attempt to send the 'stopVideo' command to the iframe's content script.
                   try {
                       // Send a message to the iframe's content window. The message is a JSON string representing the API command.
                       // The target origin '*' allows sending the message to any origin, which is often necessary for cross-origin iframes like YouTube embeds. Specifying the exact YouTube origin is more secure if possible.
                       iframe.contentWindow.postMessage('{"event":"command","func":"stopVideo","args":""}', '*'); // Send the stop command message.
                        console.log('Sent stopVideo command to potential YouTube iframe via postMessage on popup close.'); // Log the action.
                   } catch (error) {
                        // Catch and log any errors that occur during the `postMessage` attempt.
                        console.error('Failed to send stopVideo postMessage to iframe:', error); // Log the error details.
                   }
               } else {
                    // Optional: Log if no potential YouTube iframe was found or if postMessage was not supported.
                    // console.log('No active YouTube iframe found in popup or postMessage not supported for stopping video on close.');
               }
                // Regardless of whether a video was successfully stopped, reset the global `videoPlaying` flag to `false`.
                // This ensures that the flag is in the correct state (not indicating a video is playing) after the popup is closed,
                // preventing issues when trying to open a new description popup later.
                videoPlaying = false;
                console.log('Video playing flag reset to false upon closing popup.');

           } else {
               // Log an error if the popup modal element was not found in the DOM.
               console.error('Popup modal element (#popup-modal) not found. Cannot execute closePopup functionality.');
           }
        }


        // --- Chatbot Functionality ---
        // This section contains the core logic for the chatbot feature.
        // It includes functions to create the floating chatbot bubble, append messages to the chat display,
        // show/hide a typing indicator, and generate simple bot responses.

        // The floating chatbot bubble button is created and appended to the document body later, on window load.

        /**
         * Creates an HTML button element for the floating chatbot bubble and appends it to the document body.
         * This bubble serves as the initial entry point for the chatbot when the main widget is hidden.
         * It's positioned fixed at the bottom-right of the viewport.
         */
        function createChatbotBubble() {
          console.log('Attempting to create chatbot bubble.'); // Log the start of the function.
          // Check if an element with the intended bubble ID already exists in the DOM.
          // This prevents creating multiple bubble buttons if the function is called more than once.
          if (document.getElementById('chatbot-bubble')) {
              console.log('Chatbot bubble element with ID #chatbot-bubble already exists, skipping creation.'); // Log if it already exists.
              return; // Exit the function if the bubble is already present.
          }
          const bubble = document.createElement('button'); // Create a new button element for the bubble.
          bubble.id = 'chatbot-bubble'; // Assign a unique ID to the bubble element.
          bubble.setAttribute('aria-label', 'Open chat'); // Set an ARIA label for accessibility. This label is read by screen readers to describe the button's purpose.
          // Apply Tailwind CSS classes for styling: fixed positioning (bottom-right of viewport), size (width and height), shape (rounded-full makes it circular), background color (indigo), shadow, flex layout (to center content vertically and horizontally), text color (white), cursor (pointer), a pulse animation, z-index (to layer it on top of other content), and focus styles (outline and ring).
          bubble.className = 'fixed bottom-4 right-4 w-14 h-14 bg-indigo-600 rounded-full shadow-lg flex items-center justify-center text-white cursor-pointer z-50 focus:outline-none focus:ring-2 focus:ring-indigo-500';


          // Set the inner HTML of the bubble button to display the Material Icons chat icon.
          // This requires the Material Icons font stylesheet to be loaded in the HTML head (`<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />`).
          bubble.innerHTML = '<span class="material-icons">chat</span>'; // The text 'chat' within the span element is interpreted by the Material Icons font to display the chat icon glyph.

          // Add a click event listener to the bubble button.
          // When the bubble is clicked, this listener's function is executed. Its purpose is to hide the bubble and show the main chatbot widget.
          bubble.addEventListener('click', () => {
            console.log('Chatbot bubble clicked. Initiating main chatbot widget display.'); // Log the click event.
            const chatbot = document.getElementById('chatbot'); // Get the main chatbot widget element from the DOM by its ID.
             if (chatbot) { // Check if the main chatbot widget element was successfully found.
                 chatbot.style.display = 'flex'; // Change the display style of the main chatbot widget from 'none' (its initial state in HTML) to 'flex'. This makes the widget visible.
                 // Add the 'expanded' class to the main chatbot widget element. This class is used by the CSS rules (defined in the `<style>` block) to control the widget's height and the visibility of its internal content (messages area and input form).
                 chatbot.classList.add('expanded');

                 // Get the chatbot header element to update its ARIA attribute for accessibility.
                 const chatbotHeader = document.getElementById('chatbot-header');
                 if(chatbotHeader) { // Check if the header element exists.
                      // Update the 'aria-expanded' attribute on the header to 'true'. This indicates to screen readers that the collapsible region controlled by this header (the chatbot content) is now expanded.
                      chatbotHeader.setAttribute('aria-expanded', 'true');
                 } else {
                      console.warn('Chatbot header element (#chatbot-header) not found. Cannot update aria-expanded attribute.'); // Log a warning if the header is missing.
                 }


                 // Hide the floating bubble button itself since the main chatbot widget is now open.
                 bubble.style.display = 'none'; // Set the display style to 'none'.
                 console.log('Main chatbot widget displayed. Chatbot bubble hidden.'); // Log the state change.

                  // Optional: Scroll the chatbot messages area to the very bottom when the chatbot widget is opened.
                  // This ensures that the latest messages in the conversation are immediately visible to the user.
                  const chatbotMessages = document.getElementById('chatbot-messages'); // Get the messages area element.
                  if(chatbotMessages) { // Check if the messages area element exists.
                       // Scroll to the bottom (`scrollHeight`) with a smooth animation (`behavior: 'smooth'`).
                       chatbotMessages.scrollTo({
                           top: chatbotMessages.scrollHeight,
                           behavior: 'smooth'
                       });
                       console.log('Scrolled chatbot messages to bottom upon opening.'); // Log the scroll action.
                  } else {
                       console.warn('Chatbot messages container (#chatbot-messages) not found. Cannot scroll messages on open.'); // Log a warning if the messages area is missing.
                  }

             } else {
                 // Log an error if the main chatbot widget element was not found in the DOM.
                 // This means the main chatbot structure might be missing or have an incorrect ID.
                 console.error('Main chatbot element (#chatbot) not found in the DOM. Cannot open chatbot.'); // Log the critical error.
             }
          });

          // Append the newly created chatbot bubble button element to the document body.
          document.body.appendChild(bubble);
           console.log('Chatbot bubble element appended to document body.'); // Log successful appending.
        }

        /**
         * Appends a new message element to the chatbot messages display area.
         * Each message is represented by a div with styling applied based on whether the sender is the 'user' or the 'bot'.
         * After appending, it automatically scrolls the messages area to ensure the newest message is visible.
         * @param {'user'|'bot'} sender - The sender of the message. Must be either 'user' or 'bot'.
         * @param {string} message - The text content of the message to be displayed.
         */
        function appendChatMessage(sender, message) {
          const chatbotMessages = document.getElementById('chatbot-messages'); // Get the messages display area element by its ID.
           if (!chatbotMessages) { // Check if the messages area element was successfully found.
               console.error('Chatbot messages container (#chatbot-messages) not found. Cannot append message.'); // Log an error if the container is missing.
               return; // Exit the function if the container is missing.
           }
          const msgDiv = document.createElement('div'); // Create a new div element to contain the message text.

          // Apply dynamic Tailwind CSS classes to the message div based on the sender.
          // This controls the message's alignment, background color, text color, shape, spacing, and animation.
          msgDiv.className = sender === 'user'
            // Classes for user messages: margin-left auto (pushes to right), bottom margin, light indigo background, dark indigo text, rounded corners, padding, max width, allows word breaking, fade-in animation, small shadow.
            ? 'inline-block bg-indigo-100 text-indigo-900 rounded-lg px-3 py-2 max-w-[80%] break-words animate-fadeIn shadow-sm'
            // Classes for bot messages: margin-right auto (pushes to left), bottom margin, light gray background, dark gray text, rounded corners, padding, max width, allows word breaking, fade-in animation, small shadow.
            : 'inline-block bg-gray-200 text-gray-800 rounded-lg px-3 py-2 max-w-[80%] break-words animate-fadeIn shadow-sm';

          msgDiv.textContent = message; // Set the text content of the message div. Using `textContent` is crucial to prevent potential Cross-Site Scripting (XSS) vulnerabilities if the `message` string could contain HTML or script tags from an untrusted source. It interprets the input purely as text.

          chatbotMessages.appendChild(msgDiv); // Append the new message div element as a child to the messages container. This adds the message to the display.

          // Automatically scroll the messages area to the bottom after appending a new message.
           // This ensures that the latest message in the conversation is always visible to the user.
           // Use the `scrollTo` method with `behavior: 'smooth'` for a smooth scrolling animation.
           chatbotMessages.scrollTo({
               top: chatbotMessages.scrollHeight, // Scroll vertically to the maximum possible scroll height (which is the bottom of the content).
               behavior: 'smooth' // Apply a smooth animation during the scroll.
           });
           console.log(`Appended '${sender}' message to chatbot messages.`); // Log that a message was appended.
        }

        /**
         * Displays a "Chatbot is typing..." indicator message in the chatbot message area.
         * This provides visual feedback to the user that the bot is processing their request.
         * Includes a check to prevent adding multiple typing indicators if called repeatedly.
         */
        function showTypingIndicator() {
          const chatbotMessages = document.getElementById('chatbot-messages'); // Get the messages area element.
           if (!chatbotMessages) { // Check if the messages area element was found.
               console.error('Chatbot messages container (#chatbot-messages) not found for displaying typing indicator.'); // Log an error if the container is missing.
               return; // Exit the function.
           }
          const typingIndicatorId = 'typing-indicator'; // Define a unique ID for the typing indicator element.
          // Check if an element with this specific ID already exists in the DOM. This prevents adding multiple "Chatbot is typing..." messages if `showTypingIndicator` is called before the previous indicator is hidden.
          if (!document.getElementById(typingIndicatorId)) {
            const typingDiv = document.createElement('div'); // Create a new div element for the indicator message.
            typingDiv.id = typingIndicatorId; // Assign the unique ID to the new div.
             // Apply Tailwind CSS classes for styling: alignment (aligned left), text color (gray), font style (italic), padding, and a pulse animation (to make it subtly visually active).
            typingDiv.className = 'mr-auto mb-2 text-gray-500 italic animate-pulse px-3 py-2';
            typingDiv.textContent = 'Chatbot is typing...'; // Set the text content of the indicator message.
            chatbotMessages.appendChild(typingDiv); // Append the indicator div to the messages container.
            // Scroll the messages area to the bottom to make sure the typing indicator is visible.
            chatbotMessages.scrollTop = chatbotMessages.scrollHeight; // Use instant scroll to the bottom.
             console.log('Displayed chatbot typing indicator.'); // Log that the indicator was shown.
          }
        }

        /**
         * Removes the "Chatbot is typing..." indicator message from the chatbot message area.
         * This is called after the bot has finished generating and sending its response.
         */
        function hideTypingIndicator() {
          const typingDiv = document.getElementById('typing-indicator'); // Get the typing indicator element by its unique ID.
          // Check if the element exists in the DOM before attempting to remove it.
          if (typingDiv) {
            typingDiv.remove(); // Remove the typing indicator element from the DOM.
             console.log('Hid chatbot typing indicator.'); // Log that the indicator was hidden.
          }
        }

        /**
         * Simple function to generate a basic chatbot response based on keywords found in the user's message.
         * This function provides predefined responses for a limited set of keywords.
         * This is a demonstration placeholder; a real-world chatbot would typically require
         * integrating with a more sophisticated Natural Language Processing (NLP) service or a backend API.
         * @param {string} message - The user's input message string received from the chat input field.
         * @returns {string} A predefined response string if keywords are matched, or a general fallback message if no keywords are recognized.
         */
        function getBotResponse(message) {
          // Convert the user's message to lowercase. This makes the keyword matching case-insensitive.
          const msg = message.toLowerCase();

          // Use conditional statements (`if` statements) to check if the lowercase message string includes specific keywords or phrases.
          // If a match is found, return a corresponding predefined response string.
          if (msg.includes('hello') || msg.includes('hi') || msg === 'hey') {
            return 'Hello! How can I assist you with our hygiene and cleaning products today?';
          }
          if (msg.includes('recommend') || msg.includes('suggest')) {
            return 'I recommend checking out our top-rated disinfectants and hand sanitizers! You can find them in the product list above.';
          }
           if (msg.includes('price') || msg.includes('cost')) {
             return 'Prices vary by product. Please click on a product card to see its details and current pricing sourced from Amazon.';
           }
           if (msg.includes('buy') || msg.includes('purchase') || msg.includes('order')) {
             return 'You can purchase products by clicking the "Pay with Amazon" or "View on Amazon" buttons on each product card. This will take you to Amazon to complete your purchase.';
           }
            if (msg.includes('shipping')) {
                return 'Shipping is handled by Amazon. Details will be available on the Amazon product page.';
            }
             if (msg.includes('contact') || msg.includes('support') || msg.includes('help')) {
                 return 'I am an automated assistant. If you need further help, please refer to the product details on Amazon or check the site footer for contact information (if available).';
             }
            if (msg.includes('thank you') || msg.includes('thanks')) {
                return 'You\'re welcome!';
            }
            if (msg.includes('about us') || msg.includes('what is this site')) {
                 return 'This is an affiliate store showcasing hygiene and cleaning products available on Amazon. We earn a commission from qualifying purchases when you buy through our links.';
            }
             if (msg.includes('return policy') || msg.includes('returns')) {
                 return 'Returns are handled by Amazon. Please refer to Amazon\'s return policy on their website.';
             }


          // If none of the specific keywords or phrases are matched in the user's message, return a general fallback response.
          return 'Sorry, I am still learning and cannot fully understand your request. Please ask about specific products, categories, or the general buying process.';
        }
        // --- End Chatbot Functionality ---


        // --- Ad Rotation Functionality ---
        // These functions handle rotating the text content displayed within the designated ad elements on the page.
        // The rotation is performed automatically based on predefined texts and display durations using setTimeout timers.

        /**
         * Rotates the text content of a specified HTML element (an ad slot) periodically.
         * It cycles through an array of ad texts, displaying each text for a corresponding duration specified in a parallel array.
         * The function uses `setTimeout` to schedule the transition to the next ad, creating a continuous rotation loop.
         * @param {string} adElementId - The ID of the HTML element where the ad text should be displayed (e.g., 'top-ad', 'mid-ad').
         * @param {string[]} adTexts - An array of text strings, where each string is a different ad message to be displayed.
         * @param {number[]} displayTimes - An array of display durations (in milliseconds) for each corresponding ad text. The duration at index `i` in this array specifies how long the ad text at index `i` in `adTexts` should be displayed. The length of this array should ideally match or be greater than the length of `adTexts`.
         */
        function rotateAds(adElementId, adTexts, displayTimes) {
            const adElement = document.getElementById(adElementId); // Get the HTML element that serves as the ad slot by its ID.

            // Validate that the ad element was successfully found in the DOM.
            if (!adElement) {
                console.error(`Ad element not found with ID: #${adElementId}. Ad rotation cannot start.`); // Log a critical error if the element is missing.
                return; // Exit the function immediately if the ad element is not found.
            }
             // Validate that the ad texts and display times are provided as arrays and contain at least one item.
            if (!Array.isArray(adTexts) || adTexts.length === 0 || !Array.isArray(displayTimes) || displayTimes.length === 0) {
                 console.warn(`Ad texts or display times arrays are invalid or empty for #${adElementId}. Ad rotation skipped.`); // Log a warning.
                 // Optional: If the ad texts array is not empty but display times are, display the first ad text permanently.
                 adElement.textContent = adTexts && adTexts.length > 0 ? adTexts[0] : 'Advertisement'; // Display a default text or the first ad if available.
                 return; // Stop rotation if data is invalid or empty.
            }
             // Determine the effective length for the rotation cycle. Use the minimum length of the two arrays to prevent accessing
             // indices that do not exist in one of the arrays, which would cause errors.
            const effectiveLength = Math.min(adTexts.length, displayTimes.length);
            if (adTexts.length !== displayTimes.length) {
                // Warn the user if the lengths of the text and duration arrays don't match.
                console.warn(`Ad texts array length (${adTexts.length}) and display times array length (${displayTimes.length}) are different for #${adElementId}. Using the shorter length (${effectiveLength}) for the rotation cycle to avoid errors.`);
            }

            // Initialize the index for the current ad text that should be displayed. Starts at the first ad (index 0).
            let adIndex = 0;

            /**
             * Inner function `updateAd`. This function is called repeatedly by `setTimeout`
             * to update the ad text and schedule the next update. It forms the core of the rotation logic.
             */
            function updateAd() {
                 // If the effective length is 0 (meaning no valid ad texts or display times were available), stop the rotation process.
                 if (effectiveLength === 0) {
                     console.warn(`No valid ad texts or display times (effective length is 0) for #${adElementId}. Stopping rotation loop.`);
                     return; // Exit the recursive `setTimeout` call chain.
                 }

                // Set the text content of the ad element to the current ad text from the `adTexts` array.
                adElement.textContent = adTexts[adIndex];
                // Get the corresponding display duration for the currently displayed ad text from the `displayTimes` array.
                const currentDisplayTime = displayTimes[adIndex];

                // Calculate the index for the next ad in the rotation sequence.
                // The modulo operator (`% effectiveLength`) ensures that when `adIndex` reaches the `effectiveLength`,
                // it wraps back around to 0, restarting the cycle.
                adIndex = (adIndex + 1) % effectiveLength;

                // Use `setTimeout` to schedule the next call to the `updateAd` function.
                // The delay before the next call is `currentDisplayTime`, which is the duration the current ad should be displayed.
                setTimeout(updateAd, currentDisplayTime);
            }

            // Start the initial ad display and the continuous rotation cycle by making the first call to the `updateAd` function.
             console.log(`Starting ad rotation for element #${adElementId} with ${effectiveLength} ad(s) in the cycle.`);
            updateAd(); // Call the function once to display the first ad immediately and initiate the timeout sequence.

        }

        // Define the arrays containing the ad texts and their corresponding display durations (in milliseconds).
        // These arrays are passed as arguments to the `rotateAds` function to configure the rotation for each ad slot.
        // Ensure that the number of elements in `topAds` matches the number of elements in `topDisplayTimes`, and similarly for `bottomAds` and `bottomDisplayTimes`.
        const topAds = [
          'Your Ad Here - Promote Your Products!', // Text for ad 1
          'Special Discount - Save 20% Today!', // Text for ad 2
          'Limited Time Offer - Buy One Get One Free!', // Text for ad 3
           'New Products Just Added!', // Text for ad 4
            'Shop Our Best Sellers!' // Text for ad 5
        ];
        const topDisplayTimes = [27000, 27000, 3000, 10000, 5000]; // Display durations for top ads (must match number of texts: 5)

        const bottomAds = [
          'Exclusive Deals on Cleaning Supplies!', // Text for ad 1
          'Free Shipping on Orders Over $50!', // Text for ad 2
          'Shop New Arrivals Now!', // Text for ad 3
          'Flash Sale - Ending in 3 Seconds!', // Text for ad 4 (short duration)
          'Clearance Items - Limited Stock!', // Text for ad 5
          'Buy More, Save More on Hygiene!', // Text for ad 6
          'Limited Stock Available!', // Text for ad 7
          'Last Chance for Special Offers!', // Text for ad 8 (short duration)
           'Don\'t Miss Out!' // Text for ad 9
        ];
        const bottomDisplayTimes = [8300, 8300, 8300, 3000, 8300, 8300, 8300, 3000, 4000]; // Display durations for bottom ads (must match number of texts: 9)

        // --- End Ad Rotation Functionality ---


        // --- Popup Close Function ---
        // This function is responsible for hiding the main popup modal (#popup-modal).
        // It is called by the click event listeners on the popup's close button and the modal's background overlay.
        // It also attempts to stop playback of any embedded YouTube video within the modal and resets the global video playing flag.
        // This function was previously defined outside the main script block in some versions; it's included here within the main script for self-containment.

        /**
         * Closes the popup modal (#popup-modal).
         * Hides the modal by adding the 'hidden' class.
         * Attempts to stop playback of any embedded YouTube video within the modal using the API.
         * Resets the global `videoPlaying` flag to `false`.
         */
        function closePopup() {
          console.log('Attempting to close popup modal.'); // Log the start of the close operation.
          const popup = document.getElementById('popup-modal'); // Get the popup modal element from the DOM.

           // Check if the popup modal element was successfully found in the DOM.
           if (popup) {
               // Add the 'hidden' class back to the modal element. Assuming Tailwind's 'hidden' class sets `display: none;`, this will effectively hide the modal from view and remove it from the document layout.
               popup.classList.add('hidden');
               console.log('Popup modal hidden via closePopup function.'); // Log that the modal is hidden.

               // --- Attempt to Stop Embedded YouTube Video Playback ---
               // Find any iframe element that is a child of the popup modal.
               // Then, filter these iframes to identify ones that are likely YouTube embeds by checking their `src` attribute for a specific pattern associated with YouTube embed URLs.
               const iframe = popup.querySelector('iframe[src*="//www.youtube.com/embed/"], iframe[src*="//youtube.com/embed/"]'); // Look for iframes whose `src` contains the standard YouTube embed path. This is a more robust check than the placeholder.
               // Check if a potential YouTube iframe was found AND if its `contentWindow` property exists AND if the `postMessage` method is available on the `contentWindow`. `postMessage` is the standard method used to communicate securely with content within an iframe, which is necessary for controlling the YouTube player via the API.
               if (iframe && iframe.contentWindow && typeof iframe.contentWindow.postMessage === 'function') {
                   // If a potential YouTube iframe is found and supports postMessage, attempt to send the 'stopVideo' command to the iframe's content script.
                   try {
                       // The YouTube Iframe API listens for specific commands sent via `postMessage` from the parent window to control the player state.
                       // The message payload `{"event":"command","func":"stopVideo","args":""}` tells the player to stop the currently playing video.
                       // The target origin '*' allows sending the message to any origin, which is often necessary for cross-origin iframes like YouTube embeds. Specifying the exact YouTube origin (`'https://www.youtube.com'`) is more secure if you can confirm the origin.
                       iframe.contentWindow.postMessage('{"event":"command","func":"stopVideo","args":""}', '*'); // Send the stop command message.
                        console.log('Sent stopVideo command to potential YouTube iframe via postMessage on popup close.'); // Log the action.
                   } catch (error) {
                        // Catch and log any errors that occur during the `postMessage` attempt.
                        console.error('Failed to send stopVideo postMessage to iframe:', error); // Log the error details.
                   }
               } else {
                    // Optional: Log if no potential YouTube iframe was found or if postMessage was not supported.
                    // console.log('No active YouTube iframe found in popup or postMessage not supported for stopping video on close.');
               }
                // Regardless of whether a video was successfully stopped, reset the global `videoPlaying` flag to `false`.
                // This ensures that the flag is in the correct state (not indicating a video is playing) after the popup is closed,
                // preventing issues when trying to open a new description popup later.
                videoPlaying = false;
                console.log('Video playing flag reset to false upon closing popup.');

           } else {
               // Log an error if the popup modal element was not found in the DOM.
               console.error('Popup modal element (#popup-modal) not found. Cannot execute closePopup functionality.');
           }
        }


        // --- Service Worker Registration ---
        // This function initiates the registration process for the Service Worker.
        // The Service Worker file (`service-worker.js`) must be a separate file located at the root of the application's scope.
        // Service Workers enable Progressive Web App features like offline caching, background sync, etc.

        /**
         * Registers the Service Worker script.
         * The service-worker.js file is expected to be located at the root of the website's scope (`/service-worker.js`).
         * Checks for browser support before attempting registration.
         * Registration is delayed until the window's 'load' event to avoid impacting initial page load performance.
         */
        function registerServiceWorker() {
             console.log('Attempting to register service worker...'); // Log the start of the registration attempt.
            // Check if the browser's `navigator` object supports the `serviceWorker` property.
            // This is the standard way to detect Service Worker support in a browser.
            if ('serviceWorker' in navigator) {
                // Add an event listener that waits for the entire page (including all resources like images, scripts, CSS) to finish loading.
                // Delaying Service Worker registration until 'load' is a recommended practice to avoid competing for network resources with the critical initial page load.
                window.addEventListener('load', () => {
                    // Attempt to register the service worker file.
                    // The path `/service-worker.js` is relative to the *origin* of the application (usually the website root).
                    // The Service Worker's scope will be the directory it is located in and its subdirectories.
                    navigator.serviceWorker.register('/service-worker.js')
                        .then(registration => {
                            // This block is executed if the Service Worker is successfully registered.
                            console.log('Service Worker registered successfully with scope:', registration.scope); // Log success and the service worker's scope.
                             // You can monitor the state changes of the registered service worker (installing, waiting, active) via properties on the `registration` object.
                        })
                        .catch(error => {
                            // This block is executed if an error occurs during the registration process (e.g., file not found, syntax error in SW script).
                            console.error('Service Worker registration failed:', error); // Log the specific error details.
                        });
                });
            } else {
                // If the browser does not support the `serviceWorker` API, log a warning message.
                console.warn('Service workers are not supported in this browser. Progressive Web App features (like offline caching) will be unavailable.');
            }
        }
        // --- End Service Worker Registration ---


        // --- Main Execution Block ---
        // This code runs immediately when the browser finishes parsing this script tag.
        // It primarily sets up the necessary event listeners (like the window load listener)
        // and initiates processes that should start as soon as the script is available.

        console.log('main.js script loaded and executing.'); // Log that the main script file has been loaded and is starting execution.

        // Optional: Dynamically inject CSS utilities (like `.clearfix` and keyframes for `.animate-fadeIn`) if they are not
        // defined elsewhere (e.g., in your main CSS file or via Tailwind's generated output).
        // This is included as a fallback mechanism to ensure these critical styles, required by the JS for layout and animation, are present.
        const dynamicStylesId = 'dynamic-app-styles'; // Define a unique ID for the style tag.
        if(!document.getElementById(dynamicStylesId)) { // Check if a style tag with this ID hasn't been added already.
            const style = document.createElement('style'); // Create a new HTML `<style>` element.
            style.id = dynamicStylesId; // Assign the unique ID to the style tag.
            // Set the text content of the style tag to the CSS rules you want to inject.
            style.textContent = `
               /* CSS for clearing floats - ensures elements after a floated element behave correctly */
              .clearfix::after {
                 content: ""; /* Required for clearfix */
                 display: table; /* Required for clearfix */
                 clear: both; /* Clears both left and right floats */
               }
                /* Keyframes for fadeIn animation (used for chat messages) */
                /* This block defines the CSS keyframes for the fade-in animation. */
                /* Note: If this animation is already defined in your main CSS or another style block, this might be redundant but ensures it's present. */
                @keyframes fadeIn {
                  from { opacity: 0; transform: translateY(10px); } /* Start state: invisible, slightly moved down */
                  to { opacity: 1; transform: translateY(0); } /* End state: fully visible, in original position */
                }
                /* Apply the fadeIn animation to any element with the class 'animate-fadeIn'. */
                .animate-fadeIn {
                  animation: fadeIn 0.3s ease forwards; /* Apply the 'fadeIn' animation over 0.3 seconds, using ease timing, and keep the final state ('forwards'). */
                }
            `;
             // Append the dynamically created style element to the document head.
            document.head.appendChild(style);
             console.log('Injected dynamic styles (clearfix, fadeIn keyframes) into document head.'); // Log that styles were injected.
        }


        // Add a listener for the window's 'load' event.
        // The callback function provided here will execute once the entire page (including all resources like images, scripts, CSS, iframes, etc.) has finished loading.
        // This is the recommended place to perform DOM manipulation and initialize functionality that depends on the full page structure being ready.
        window.addEventListener('load', () => {
          console.log('Window load event fired. Starting main application functionalities...'); // Log that the load event has occurred and main functions are starting.

          // --- Initialize Core Application Components that Require the Full DOM ---

          // Call the function to fetch product data and then render the product cards into the product slider area.
          renderProducts();
          console.log('Product rendering process initiated on load.');

          // Setup event listeners for the popup modal. This includes the close button within the modal and the modal's background overlay itself.
          const popupClose = document.getElementById('popup-close'); // Get the popup close button element.
           const popupModal = document.getElementById('popup-modal'); // Get the main popup modal overlay element.
           if (popupClose && popupModal) { // Check if both required elements were found in the DOM.
                console.log('Popup modal elements (#popup-close, #popup-modal) found on load. Setting up close listeners.');
                // Add a click event listener to the popup close button. When clicked, it calls the `closePopup` function.
                popupClose.addEventListener('click', closePopup);
                // Add a click event listener to the main popup modal overlay element.
                popupModal.addEventListener('click', (event) => {
                    // Check if the target of the click event (`event.target`) is the modal overlay element (`popupModal`) itself.
                    // This ensures that clicking *inside* the modal content (on text, images, buttons, etc.) does not close the modal,
                    // but clicking the semi-transparent background does.
                    if (event.target === popupModal) {
                        closePopup(); // If the click occurred directly on the overlay, call the `closePopup` function.
                        console.log('Popup modal closed by clicking the overlay.'); // Log the action.
                    }
                });
           } else {
               // Log an error if essential popup elements were not found on load.
               console.error('Popup close button (#popup-close) or modal (#popup-modal) not found on load. Popup close functionality will be limited.');
           }


          // Create and append the floating chatbot bubble button to the document body.
          // This bubble is the initial visual indicator for the chatbot.
          createChatbotBubble();
          console.log('Chatbot bubble creation initiated on load.');


          // Setup the `href` attributes for the social media share links in the header.
          // Get the current page URL and a default share title, then encode them for use in URLs.
          const shareUrl = encodeURIComponent(window.location.href); // Get current page URL and encode.
          const shareTitle = encodeURIComponent('Check out these Hygiene & Cleaning Products!'); // Set and encode the share title.

           // Get each social share anchor element by its ID.
           const facebookShare = document.getElementById('share-facebook');
           // If the element is found, set its `href` attribute using the correct URL format for sharing on Facebook.
           if(facebookShare) facebookShare.href = `https://www.facebook.com/sharer/sharer.php?u=${shareUrl}`;

           const twitterShare = document.getElementById('share-twitter');
           // If found, set its `href` attribute using the correct URL format for tweeting on Twitter.
           if(twitterShare) twitterShare.href = `https://twitter.com/intent/tweet?url=${shareUrl}&text=${shareTitle}`;

           const whatsappShare = document.getElementById('share-whatsapp');
           // If found, set its `href` attribute using the correct URL format for sharing via WhatsApp API.
           if(whatsappShare) whatsappShare.href = `https://api.whatsapp.com/send?text=${shareTitle}%20${shareUrl}`;

           const linkedinShare = document.getElementById('share-linkedin');
           // If found, set its `href` attribute using the correct URL format for sharing on LinkedIn (off-site sharing).
            if(linkedinShare) linkedinShare.href = `https://www.linkedin.com/sharing/share-offsite/?url=${shareUrl}`;

            console.log('Social share link href attributes updated on window load.'); // Log completion.


          // Start the ad rotation cycles for the top and bottom ad elements.
          // This function will continuously update the text content of the specified elements.
          rotateAds('top-ad', topAds, topDisplayTimes); // Start rotation for the element with ID 'top-ad'.
          rotateAds('mid-ad', bottomAds, bottomDisplayTimes); // Start rotation for the element with ID 'mid-ad' (assuming this is the bottom ad slot).
          console.log('Ad rotation cycles started on window load.'); // Log that rotation has begun.


          // --- Chatbot Functionality Setup (Event Listeners) ---
          // Get the core chatbot-related DOM elements by their IDs.
           const chatbot = document.getElementById('chatbot'); // The main chatbot widget container.
           const chatbotHeader = document.getElementById('chatbot-header'); // The clickable header bar.
           const chatbotClose = document.getElementById('chatbot-close'); // The close button.
           const chatbotMessages = document.getElementById('chatbot-messages'); // The message display area.
           const chatbotForm = document.getElementById('chatbot-form'); // The form containing the input and send button.
           const chatbotInput = document.getElementById('chatbot-input'); // The text input field.

           // Check if all required chatbot elements were successfully found in the DOM on window load.
           // If any are missing, the chatbot functionality cannot be fully initialized.
           if (chatbot && chatbotHeader && chatbotClose && chatbotMessages && chatbotForm && chatbotInput) {
                console.log('All required chatbot elements found on load. Setting up chatbot interaction listeners.');

                // Add a click event listener to the chatbot header.
                // This listener toggles the expansion state (height and content visibility) of the main chatbot widget.
                chatbotHeader.addEventListener('click', () => {
                    // Toggle the 'expanded' class on the main chatbot element. The CSS rules tied to this class control the visual state.
                    chatbot.classList.toggle('expanded');
                     // Update the 'aria-expanded' attribute on the header for accessibility.
                     // This attribute tells screen readers whether the region controlled by the header is currently expanded or collapsed.
                     const isExpanded = chatbot.classList.contains('expanded'); // Check if the 'expanded' class is now present.
                     chatbotHeader.setAttribute('aria-expanded', isExpanded); // Set the attribute value ('true' or 'false').
                     console.log(`Chatbot header clicked. Expanded state toggled to: ${isExpanded}.`); // Log the state change.

                     // If the chatbot is now expanded, scroll the messages area to the bottom to ensure the latest conversation is visible.
                     if (isExpanded) {
                          // Check if the messages element exists before attempting to scroll.
                           if (chatbotMessages) {
                               // Use smooth scrolling to the bottom.
                               chatbotMessages.scrollTo({
                                   top: chatbotMessages.scrollHeight, // Scroll vertically to the maximum scroll height.
                                   behavior: 'smooth' // Apply a smooth animation during the scroll.
                               });
                               console.log('Chatbot expanded, scrolled messages to bottom.'); // Log the scroll action.
                           } else {
                                console.warn('Chatbot messages container (#chatbot-messages) not found. Cannot scroll messages after expansion.'); // Warn if the messages area is missing.
                           }
                     }
                });

                // Add a click event listener to the chatbot close button.
                // This listener handles closing and hiding the main chatbot widget.
                chatbotClose.addEventListener('click', () => {
                     console.log('Chatbot close button clicked. Initiating chatbot close animation and hiding.'); // Log the click event.
                     // Apply inline styles to trigger a smooth fade-out and slight downward movement animation.
                     chatbot.style.transition = 'opacity 0.3s ease, transform 0.3s ease'; // Set the CSS transition properties and duration.
                     chatbot.style.opacity = '0'; // Set the opacity to 0 to fade the widget out.
                     chatbot.style.transform = 'translateY(20px)'; // Apply a slight vertical translation downward.

                     // Use `setTimeout` to delay the complete hiding of the element until after the CSS transition completes.
                     setTimeout(() => {
                       chatbot.style.display = 'none'; // Set the display style to 'none'. This completely hides the element and removes it from the document layout.
                       // Reset the transition-related inline styles so they don't interfere the next time the chatbot is opened.
                       chatbot.style.opacity = ''; // Reset opacity to its default value (or 1).
                       chatbot.style.transform = 'translateY(0)'; // Reset transform to translateY(0).

                       chatbot.style.transition = ''; // Remove the transition property itself.

                       // Ensure the 'expanded' class is removed and the aria-expanded attribute is set to false when the widget is closed.
                       chatbot.classList.remove('expanded'); // Remove the class.
                        chatbotHeader.setAttribute('aria-expanded', 'false'); // Set the aria-expanded attribute to 'false'.


                       // Show the floating chatbot bubble button again, as the main widget is now closed.
                       const bubble = document.getElementById('chatbot-bubble'); // Get the bubble element.
                       if (bubble) { // Check if the bubble element exists.
                            bubble.style.display = 'flex'; // Change its display style back to 'flex' to make it visible.
                            console.log('Chatbot closed via button. Chatbot bubble shown.'); // Log the action.
                       } else {
                            console.warn('Chatbot bubble element (#chatbot-bubble) not found.'); // Warn if the bubble is missing.
                       }
                     }, 300); // The delay duration (in milliseconds) matches the duration of the CSS transition (0.3 seconds).
                });

                // Add a submit event listener to the chatbot form element.
                // This listener is triggered when the user submits the form (by pressing Enter in the input field or clicking the send button).
                chatbotForm.addEventListener('submit', (e) => {
                    e.preventDefault(); // Prevent the browser's default form submission behavior, which would cause a page reload.

                    // Get the user's message from the input field and remove any leading or trailing whitespace.
                    const userMessage = chatbotInput.value.trim();

                    // If the trimmed message is empty (contains only whitespace or is blank), do not process or send it.
                    if (!userMessage) {
                         console.log('Attempted to send empty message in chatbot form.'); // Log the attempt to send an empty message.
                         return; // Exit the event handler function without further action.
                    }

                    // Append the user's message to the chatbot messages display area.
                    appendChatMessage('user', userMessage);

                    // Clear the text from the input field after the message has been sent.
                    chatbotInput.value = '';

                    // Display the "Chatbot is typing..." indicator to provide feedback to the user.
                    showTypingIndicator();

                    // Simulate a delay before the chatbot generates and sends its response.
                    // In a real-world chatbot application, this delay would typically represent the time taken to send the user's input to a backend API, process it (NLP, decision logic), and receive a response back.
                    setTimeout(() => {
                        // Call the `getBotResponse` function to get a predefined response based on the user's message input.
                        const botResponse = getBotResponse(userMessage);
                        // Append the bot's response message to the chatbot messages display area.
                        appendChatMessage('bot', botResponse);
                        // Hide the "Chatbot is typing..." indicator now that the bot's response has been displayed.
                        hideTypingIndicator();
                         console.log('Chatbot responded to user message after simulated delay.'); // Log that the response was sent.
                    }, 1500); // The delay duration in milliseconds (1500ms = 1.5 seconds). Adjust this value to simulate a longer or shorter processing time.
                });

               // Set the initial state of the chatbot widget when the script runs on window load.
               // It should be hidden and collapsed by default, as defined by the initial HTML structure and CSS.
               chatbot.style.display = 'none'; // Explicitly set display to 'none' via inline style to ensure it's hidden initially.
               chatbot.classList.remove('expanded'); // Ensure the 'expanded' class is not present, so it starts in the collapsed state according to CSS.
                chatbotHeader.setAttribute('aria-expanded', 'false'); // Set the initial 'aria-expanded' attribute on the header to 'false', indicating it's collapsed.


            } else {
                 // Log an error if any of the required chatbot elements were not found in the DOM on window load.
                 // This indicates that the chatbot functionality cannot be fully initialized or function correctly.
                 console.error('One or more required chatbot elements not found on window load (#chatbot, #chatbot-header, #chatbot-close, #chatbot-messages, #chatbot-form, or #chatbot-input). Chatbot functionality will be disabled.');
            }

            // --- End Chatbot Functionality Setup ---


            // --- Service Worker Registration ---
            // Call the function to initiate the registration process for the Service Worker.
            // This function is defined earlier in this script block.
            // The Service Worker script file (`service-worker.js`) must be a separate file located at the root of your application's scope.
            registerServiceWorker();
             console.log('Service Worker registration process initiated on window load.'); // Log that the registration function was called.
            // --- End Service Worker Registration ---


        }); // --- End of window.addEventListener('load', ...) ---


        // Note: The `startAutoScroll` function was mentioned in previous code snippets as a potential
        // feature for the product slider, but its implementation was not provided.
        // If you require the product slider to auto-scroll horizontally, you must
        // implement the `startAutoScroll` function (which takes the container element as an argument)
        // and call it from within the `renderProducts` function *after* the product cards
        // have been added to the container. A basic example implementation outline was
        // included in comments in the notes of a previous response.


        // Note: The YouTube Iframe API script (`https://www.youtube.com/iframe_api`) is loaded
        // dynamically by the `openDescriptionPopup` function if it's needed for displaying a video
        // and is not already present in the page. The correct standard URL for the API script is used.


        // Note: The `openLinkBehind` function is defined in a separate script tag outside this main script block
        // and is used by the footer navigation links via their `onclick` attributes. This function is not part of the main script's scope
        // but is available globally.


        // --- End of main.js content ---


    </script>

    </body>
</html>
